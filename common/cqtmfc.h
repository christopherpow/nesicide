#ifndef CQTMFC_H
#define CQTMFC_H

#undef PASCAL
#define PASCAL

#include <QDialogButtonBox>
#include <QMainWindow>
#include <QShortcut>
#include <QAction>
#include <QObject>
#include <QWidget>
#include <QPainter>
#include <QDebug>
#include <QPen>
#include <QBitmap>
#include <QBrush>
#include <QSize>
#include <QStatusBar>
#include <QToolBar>
#include <QPixmap>
#include <QFont>
#include <QRegion>
#include <QFrame>
#include <QAbstractButton>
#include <QRadioButton>
#include <QComboBox>
#include <QProgressBar>
#include <QClipboard>
#include <QScrollBar>
#include <QEvent>
#include <QList>
#include <QHash>
#include <QTimer>
#include <QPaintEvent>
#include <QMouseEvent>
#include <QKeyEvent>
#include <QTimerEvent>
#include <QWheelEvent>
#include <QResizeEvent>
#include <QObject>
#include <QThread>
#include <QFile>
#include <QMutex>
#include <QByteArray>
#include <QGridLayout>
#include <QMimeData>
#include <QElapsedTimer>
#include <QSharedMemory>
#include <QSettings>
#include <QMutex>
#include <QSemaphore>
#include <QListWidget>
#include <QDialog>
#include <QMenu>
#include <QListWidget>
#include <QTableWidget>
#include <QTreeWidget>
#include <QSpinBox>
#include <QPushButton>
#include <QLabel>
#include <QPlainTextEdit>
#include <QLineEdit>
#include <QCheckBox>
#include <QGroupBox>
#include <QFileDialog>
#include <QColorDialog>
#include <QToolButton>
#include <QLibrary>
#include <QToolTip>

#ifndef QT_NO_DEBUG
//#define _DEBUG
#endif

// Stuff from mingw/include/windowsx.h
#define WM_CTLCOLOR 25

// Stuff from mingw/include/commctrl.h
// CP picked a _WIN32_IE
#define _WIN32_IE 0x0501

#define DRAGLISTMSGSTRING TEXT("commctrl_DragListMsg")
#define HOTKEY_CLASSA	"msctls_hotkey32"
#define HOTKEY_CLASSW	L"msctls_hotkey32"
#define PROGRESS_CLASSA	"msctls_progress32"
#define PROGRESS_CLASSW	L"msctls_progress32"
#define STATUSCLASSNAMEA	"msctls_statusbar32"
#define STATUSCLASSNAMEW	L"msctls_statusbar32"
#define TOOLBARCLASSNAMEA	"ToolbarWindow32"
#define TOOLBARCLASSNAMEW	L"ToolbarWindow32"
#define TOOLTIPS_CLASSA	"tooltips_class32"
#define TOOLTIPS_CLASSW	L"tooltips_class32"
#define TRACKBAR_CLASSA	"msctls_trackbar32"
#define TRACKBAR_CLASSW	L"msctls_trackbar32"
#define UPDOWN_CLASSA	"msctls_updown32"
#define UPDOWN_CLASSW	L"msctls_updown32"
#define ANIMATE_CLASSA	"SysAnimate32"
#define ANIMATE_CLASSW	L"SysAnimate32"
#define DATETIMEPICK_CLASSW L"SysDateTimePick32"
#define DATETIMEPICK_CLASSA "SysDateTimePick32"
#define MONTHCAL_CLASSW L"SysMonthCal32"
#define MONTHCAL_CLASSA "SysMonthCal32"
#define REBARCLASSNAMEW L"ReBarWindow32"
#define REBARCLASSNAMEA "ReBarWindow32"
#define WC_COMBOBOXEXW	L"ComboBoxEx32"
#define WC_COMBOBOXEXA	"ComboBoxEx32"
#define WC_IPADDRESSW	L"SysIPAddress32"
#define WC_IPADDRESSA	"SysIPAddress32"
#define WC_LISTVIEWA	"SysListView32"
#define WC_LISTVIEWW	L"SysListView32"
#define WC_TABCONTROLA	"SysTabControl32"
#define WC_TABCONTROLW	L"SysTabControl32"
#define WC_TREEVIEWA	"SysTreeView32"
#define WC_TREEVIEWW	L"SysTreeView32"
#define WC_HEADERA	"SysHeader32"
#define WC_HEADERW 	L"SysHeader32"
#define WC_PAGESCROLLERW	L"SysPager"
#define WC_PAGESCROLLERA	"SysPager"
#define WC_NATIVEFONTCTLW	L"NativeFontCtl"
#define WC_NATIVEFONTCTLA	"NativeFontCtl"
#define WC_BUTTONA	"Button"
#define WC_BUTTONW	L"Button"
#define WC_STATICA	"Static"
#define WC_STATICW	L"Static"
#define WC_EDITA	"Edit"
#define WC_EDITW	L"Edit"
#define WC_LISTBOXA	"ListBox"
#define WC_LISTBOXW	L"ListBox"
#define WC_COMBOBOXA	"ComboBox"
#define WC_COMBOBOXW	L"ComboBox"
#define WC_SCROLLBARA	"ScrollBar"
#define WC_SCROLLBARW	L"ScrollBar"
#define WC_LINKA	"SysLink"
#define WC_LINKW	L"SysLink"

#ifdef UNICODE
#define HOTKEY_CLASS HOTKEY_CLASSW
#define PROGRESS_CLASS PROGRESS_CLASSW
#define STATUSCLASSNAME STATUSCLASSNAMEW
#define TOOLBARCLASSNAME TOOLBARCLASSNAMEW
#define TOOLTIPS_CLASS TOOLTIPS_CLASSW
#define TRACKBAR_CLASS TRACKBAR_CLASSW
#define UPDOWN_CLASS UPDOWN_CLASSW
#define ANIMATE_CLASS ANIMATE_CLASSW
#define DATETIMEPICK_CLASS DATETIMEPICK_CLASSW
#define MONTHCAL_CLASS MONTHCAL_CLASSW
#define REBARCLASSNAME REBARCLASSNAMEW
#define WC_COMBOBOXEX WC_COMBOBOXEXW
#define WC_HEADER WC_HEADERW
#define WC_IPADDRESS WC_IPADDRESSW
#define WC_LISTVIEW WC_LISTVIEWW
#define WC_TABCONTROL WC_TABCONTROLW
#define WC_TREEVIEW WC_TREEVIEWW
#define WC_PAGESCROLLER WC_PAGESCROLLERW
#define WC_NATIVEFONTCTL WC_NATIVEFONTCTLW
#define WC_BUTTON WC_BUTTONW
#define WC_STATIC WC_STATICW
#define WC_EDIT WC_EDITW
#define WC_LISTBOX WC_LISTBOXW
#define WC_COMBOBOX WC_COMBOBOXW
#define WC_SCROLLBAR WC_SCROLLBARW
#define WC_LINK WC_LINKW
#else
#define ANIMATE_CLASS ANIMATE_CLASSA
#define HOTKEY_CLASS HOTKEY_CLASSA
#define PROGRESS_CLASS PROGRESS_CLASSA
#define STATUSCLASSNAME STATUSCLASSNAMEA
#define TOOLBARCLASSNAME TOOLBARCLASSNAMEA
#define TOOLTIPS_CLASS TOOLTIPS_CLASSA
#define TRACKBAR_CLASS TRACKBAR_CLASSA
#define UPDOWN_CLASS UPDOWN_CLASSA
#define DATETIMEPICK_CLASS DATETIMEPICK_CLASSA
#define MONTHCAL_CLASS MONTHCAL_CLASSA
#define REBARCLASSNAME REBARCLASSNAMEA
#define WC_COMBOBOXEX WC_COMBOBOXEXA
#define WC_HEADER WC_HEADERA
#define WC_IPADDRESS WC_IPADDRESSA
#define WC_LISTVIEW WC_LISTVIEWA
#define WC_TABCONTROL WC_TABCONTROLA
#define WC_TREEVIEW WC_TREEVIEWA
#define WC_PAGESCROLLER WC_PAGESCROLLERA
#define WC_NATIVEFONTCTL WC_NATIVEFONTCTLA
#define WC_BUTTON WC_BUTTONA
#define WC_STATIC WC_STATICA
#define WC_EDIT WC_EDITA
#define WC_LISTBOX WC_LISTBOXA
#define WC_COMBOBOX WC_COMBOBOXA
#define WC_SCROLLBAR WC_SCROLLBARA
#define WC_LINK WC_LINKA
#endif

#if (_WIN32_IE >= 0x0500)
#if (_WIN32_WINNT >= 0x0501)
#define COMCTL32_VERSION 6
#else
#define COMCTL32_VERSION 5
#endif
#endif

#define LVM_FIRST 0x1000
#define TV_FIRST 0x1100
#define HDM_FIRST 0x1200
#define ACM_OPENA	(WM_USER+100)
#define ACM_PLAY	(WM_USER+101)
#define ACM_STOP	(WM_USER+102)
#define ACM_OPENW	(WM_USER+103)
#define ACN_START	1
#define ACN_STOP	2
#define CBEIF_TEXT	0x00000001
#define CBEIF_IMAGE	0x00000002
#define CBEIF_SELECTEDIMAGE	0x00000004
#define CBEIF_OVERLAY	0x00000008
#define CBEIF_INDENT	0x00000010
#define CBEIF_LPARAM	0x00000020
#define CBEIF_DI_SETITEM	0x10000000
#define CBEN_INSERTITEM	(CBEN_FIRST - 1)
#define CBEN_DELETEITEM	(CBEN_FIRST - 2)
#define CBEN_BEGINEDIT	(CBEN_FIRST - 4)
#define CBEN_ENDEDITA	(CBEN_FIRST - 5)
#define CBEN_ENDEDITW	(CBEN_FIRST - 6)
#define CBENF_KILLFOCUS	1
#define CBENF_RETURN	2
#define CBENF_ESCAPE	3
#define CBENF_DROPDOWN	4
#define CBEMAXSTRLEN 260
#define DL_BEGINDRAG	1157
#define DL_CANCELDRAG	1160
#define DL_DRAGGING	1158
#define DL_DROPPED	1159
#define DL_CURSORSET	0
#define DL_STOPCURSOR	1
#define DL_COPYCURSOR	2
#define DL_MOVECURSOR	3
#define CCS_TOP	1
#define CCS_NOMOVEY	2
#define CCS_BOTTOM	3
#define CCS_NORESIZE	4
#define CCS_NOPARENTALIGN	8
#define CCS_ADJUSTABLE	32
#define CCS_NODIVIDER	64
#if (_WIN32_IE >= 0x0300)
#define CCS_VERT 128
#define CCS_LEFT 129
#define CCS_NOMOVEX 130
#define CCS_RIGHT 131
#endif
#define ACS_CENTER	0x0001
#define ACS_TRANSPARENT	0x0002
#define ACS_AUTOPLAY	0x0004
#define ACS_TIMER	0x0008
#define PGS_VERT	0x00000000
#define PGS_HORZ	0x00000001
#define PGS_AUTOSCROLL	0x00000002
#define PGS_DRAGNDROP	0x00000004
#define CMB_MASKED	2
#define MINSYSCOMMAND	SC_SIZE
#define SBT_OWNERDRAW	0x1000
#define SBT_NOBORDERS	256
#define SBT_POPOUT	512
#define SBT_RTLREADING	1024
#define SB_SETTEXTA	(WM_USER+1)
#define SB_SETTEXTW	(WM_USER+11)
#define SB_GETTEXTA	(WM_USER+2)
#define SB_GETTEXTW	(WM_USER+13)
#define SB_GETTEXTLENGTHA	(WM_USER+3)
#define SB_GETTEXTLENGTHW	(WM_USER+12)
#define SB_SETPARTS	(WM_USER+4)
#define SB_GETPARTS	(WM_USER+6)
#define SB_GETBORDERS	(WM_USER+7)
#define SB_SETMINHEIGHT	(WM_USER+8)
#define SB_SIMPLE	(WM_USER+9)
#define SB_GETRECT	(WM_USER+10)
#define MSGF_COMMCTRL_BEGINDRAG	0x4200
#define MSGF_COMMCTRL_SIZEHEADER	0x4201
#define MSGF_COMMCTRL_DRAGSELECT	0x4202
#define MSGF_COMMCTRL_TOOLBARCUST	0x4203
#define ILC_COLOR 0
#define ILC_COLOR4 4
#define ILC_COLOR8 8
#define ILC_COLOR16 16
#define ILC_COLOR24 24
#define ILC_COLOR32 32
#define ILC_COLORDDB 254
#define ILC_MASK 1
#define ILC_PALETTE 2048
#define ILCF_MOVE 0
#define ILCF_SWAP 1
#define ILS_NORMAL 0
#define ILS_GLOW 1
#define ILS_SHADOW 2
#define ILS_SATURATE 4
#define ILS_ALPHA 8
#define ILD_BLEND25 2
#define ILD_BLEND50 4
#define ILD_SELECTED 4
#define ILD_BLEND 4
#define ILD_FOCUS 2
#define ILD_MASK 16
#define ILD_NORMAL 0
#define ILD_TRANSPARENT 1
#define ILD_IMAGE 0x0020
#define ILD_ROP 0x0040
#define ILD_OVERLAYMASK 0x0F00
#define ILD_PRESERVEALPHA 0x1000
#define ILD_SCALE 0x2000
#define ILD_DPISCALE 0x4000
#define HDS_HORZ	0
#define HDS_BUTTONS	2
#define HDS_HIDDEN	8
#if (_WIN32_IE > 0x0300)
#define HDS_HOTTRACK	4
#define HDS_DRAGDROP	0x0040
#define HDS_FULLDRAG	0x0080
#endif /* _WIN32_IE > 0x0300 */
#if (_WIN32_IE >= 0x0500)
#define HDS_FILTERBAR	0x0100
#endif /* _WIN32_IE >= 0x0500 */
#define NM_FIRST	0
#define NM_LAST	((UINT)-99)
#define LVN_FIRST	((UINT)-100)
#define LVN_LAST	((UINT)-199)
#define HDN_FIRST	((UINT)-300)
#define HDN_LAST	((UINT)-399)
#define TVN_FIRST	((UINT)-400)
#define TVN_LAST	((UINT)-499)
#define TTN_FIRST	((UINT)-520)
#define TTN_LAST	((UINT)-549)
#define TCN_FIRST	((UINT)-550)
#define TCN_LAST	((UINT)-580)
#ifndef CDN_FIRST
#define CDN_FIRST	((UINT)-601) /* also in commdlg.h */
#define CDN_LAST	((UINT)-699)
#endif
#define TBN_FIRST	((UINT)-700)
#define TBN_LAST	((UINT)-720)
#define UDN_FIRST	((UINT)-721)
#define UDN_LAST	((UINT)-740)
#if (_WIN32_IE >= 0x0300)
#define RBN_FIRST	((UINT)-831)
#define RBN_LAST	((UINT)-859)
#define MCN_FIRST	((UINT)-750)
#define MCN_LAST	((UINT)-759)
#define DTN_FIRST	((UINT)-760)
#define DTN_LAST	((UINT)-799)
#define CBEN_FIRST	((UINT)-800)
#define CBEN_LAST	((UINT)-830)
#endif /* _WIN32_IE */
#if (_WIN32_IE >= 0x0400)
#define IPN_FIRST	((UINT)-860)
#define IPN_LAST	((UINT)-879)
#define IPN_FIELDCHANGED	(IPN_FIRST-0)
#define SBN_FIRST	((UINT)-880U)
#define SBN_LAST	((UINT)-899U)
#define PGN_FIRST	((UINT)-900U)
#define PGN_LAST	((UINT)-950U)
#define PGN_SCROLL	(PGN_FIRST-1)
#define PGN_CALCSIZE	(PGN_FIRST-2)
#endif /* _WIN32_IE >= 0x0400 */
#define HDI_WIDTH	1
#define HDI_HEIGHT	1
#define HDI_TEXT	2
#define HDI_FORMAT	4
#define HDI_LPARAM	8
#define HDI_BITMAP	16
#if (_WIN32_IE >= 0x0300)
#define HDI_IMAGE	32
#define HDI_DI_SETITEM	64
#define HDI_ORDER	128
#endif
#define CBES_EX_NOEDITIMAGE	0x00000001
#define CBES_EX_NOEDITIMAGEINDENT	0x00000002
#define CBES_EX_PATHWORDBREAKPROC	0x00000004
#if (_WIN32_IE >= 0x0400)
#define CBES_EX_NOSIZELIMIT	0x00000008
#define CBES_EX_CASESENSITIVE	0x00000010
#define CBEN_GETDISPINFOA	(CBEN_FIRST - 0)
#define CBEN_GETDISPINFOW	(CBEN_FIRST - 7)
#define CBEN_DRAGBEGINA	(CBEN_FIRST - 8)
#define CBEN_DRAGBEGINW	(CBEN_FIRST - 9)
#endif /* _WIN32_IE >= 0x0400 */
#if (_WIN32_IE >= 0x0500)
#define HDI_FILTER	256
#endif
#define HDF_LEFT	0
#define HDF_RIGHT	1
#define HDF_CENTER	2
#define HDF_JUSTIFYMASK	3
#define HDF_RTLREADING	4
#define HDF_OWNERDRAW	0x8000
#define HDF_STRING	0x4000
#define HDF_BITMAP	0x2000
#if (_WIN32_IE >= 0x0300)
#define HDF_BITMAP_ON_RIGHT	0x1000
#define HDF_IMAGE	0x0800
#endif
#define HDM_GETITEMCOUNT	HDM_FIRST
#define HDM_INSERTITEMA	(HDM_FIRST+1)
#define HDM_INSERTITEMW	(HDM_FIRST+10)
#define HDM_DELETEITEM	(HDM_FIRST+2)
#define HDM_GETITEMA	(HDM_FIRST+3)
#define HDM_GETITEMW	(HDM_FIRST+11)
#define HDM_SETITEMA	(HDM_FIRST+4)
#define HDM_SETITEMW	(HDM_FIRST+12)
#define HDM_LAYOUT	(HDM_FIRST+5)
#if (_WIN32_IE >= 0x0300)
#define HDM_GETITEMRECT (HDM_FIRST+7)
#define HDM_SETIMAGELIST	(HDM_FIRST+8)
#define HDM_GETIMAGELIST	(HDM_FIRST+9)
#define HDM_ORDERTOINDEX	(HDM_FIRST+15)
#define HDM_CREATEDRAGIMAGE	(HDM_FIRST+16)
#define HDM_GETORDERARRAY	(HDM_FIRST+17)
#define HDM_SETORDERARRAY	(HDM_FIRST+18)
#define HDM_SETHOTDIVIDER	(HDM_FIRST+19)
#endif
#if (_WIN32_IE >= 0x0400)
#define HDM_GETUNICODEFORMAT	CCM_GETUNICODEFORMAT
#define HDM_SETUNICODEFORMAT	CCM_SETUNICODEFORMAT
#endif
#define HHT_NOWHERE	1
#define HHT_ONHEADER	2
#define HHT_ONDIVIDER	4
#define HHT_ONDIVOPEN	8
#define HHT_ABOVE	256
#define HHT_BELOW	512
#define HHT_TORIGHT	1024
#define HHT_TOLEFT	2048
#define HDM_HITTEST	(HDM_FIRST+6)
#define HDN_ITEMCHANGINGA	(HDN_FIRST-0)
#define HDN_ITEMCHANGINGW	(HDN_FIRST-20)
#define HDN_ITEMCHANGEDA	(HDN_FIRST-1)
#define HDN_ITEMCHANGEDW	(HDN_FIRST-21)
#define HDN_ITEMCLICKA	(HDN_FIRST-2)
#define HDN_ITEMCLICKW	(HDN_FIRST-22)
#define HDN_ITEMDBLCLICKA	(HDN_FIRST-3)
#define HDN_ITEMDBLCLICKW	(HDN_FIRST-23)
#define HDN_DIVIDERDBLCLICKA	(HDN_FIRST-5)
#define HDN_DIVIDERDBLCLICKW	(HDN_FIRST-25)
#define HDN_BEGINTRACKA	(HDN_FIRST-6)
#define HDN_BEGINTRACKW	(HDN_FIRST-26)
#define HDN_ENDTRACKA	(HDN_FIRST-7)
#define HDN_ENDTRACKW	(HDN_FIRST-27)
#define HDN_TRACKA	(HDN_FIRST-8)
#define HDN_TRACKW	(HDN_FIRST-28)
#if _WIN32_IE >= 0x0300
#define HDN_ENDDRAG	(HDN_FIRST-11)
#define HDN_BEGINDRAG	(HDN_FIRST-10)
#define HDN_GETDISPINFOA (HDN_FIRST-9)
#define HDN_GETDISPINFOW (HDN_FIRST-29)
#endif
#if (_WIN32_IE >= 0x0400)
#define HICF_OTHER 0x00
#define HICF_MOUSE 0x01
#define HICF_ARROWKEYS 0x02
#define HICF_ACCELERATOR 0x04
#define HICF_DUPACCEL 0x08
#define HICF_ENTERING 0x10
#define HICF_LEAVING 0x20
#define HICF_RESELECT 0x40
#define HICF_LMOUSE 0x80
#define HICF_TOGGLEDROPDOWN 0x100
#endif /* _WIN32_IE >= 0x0400 */
#define IPM_CLEARADDRESS	(WM_USER+100)
#define IPM_SETADDRESS	(WM_USER+101)
#define IPM_GETADDRESS	(WM_USER+102)
#define IPM_SETRANGE	(WM_USER+103)
#define IPM_SETFOCUS	(WM_USER+104)
#define IPM_ISBLANK	(WM_USER+105)
#if (_WIN32_IE >= 0x0500)
#define I_INDENTCALLBACK (-1)
#define I_IMAGENONE (-2)
#endif
#define CMB_MASKED 2
#define TBSTATE_CHECKED	1
#define TBSTATE_PRESSED	2
#define TBSTATE_ENABLED	4
#define TBSTATE_HIDDEN	8
#define TBSTATE_INDETERMINATE	16
#define TBSTATE_WRAP	32
#if (_WIN32_IE >= 0x0300)
#define TBSTATE_ELLIPSES 0x40
#endif
#if (_WIN32_IE >= 0x0400)
#define TBSTATE_MARKED	0x0080
#endif
#define TBSTYLE_BUTTON	0
#define TBSTYLE_SEP	1
#define TBSTYLE_CHECK	2
#define TBSTYLE_GROUP	4
#define TBSTYLE_CHECKGROUP	(TBSTYLE_GROUP|TBSTYLE_CHECK)
#if (_WIN32_IE >= 0x0300)
#define TBSTYLE_DROPDOWN	8
#endif
#if (_WIN32_IE >= 0x0400)
#define TBSTYLE_AUTOSIZE	16
#define TBSTYLE_NOPREFIX	32
#endif
#define TBSTYLE_TOOLTIPS	256
#define TBSTYLE_WRAPABLE	512
#define TBSTYLE_ALTDRAG	1024
#if (_WIN32_IE >= 0x0300)
#define TBSTYLE_FLAT 2048
#define TBSTYLE_LIST 4096
#define TBSTYLE_CUSTOMERASE 8192
#endif
#if (_WIN32_IE >= 0x0400)
#define TBSTYLE_REGISTERDROP	0x4000
#define TBSTYLE_TRANSPARENT	0x8000
#define TBSTYLE_EX_DRAWDDARROWS	0x00000001
#endif /* _WIN32_IE >= 0x0400 */
#if (_WIN32_IE >= 0x0501)
#define TBSTYLE_EX_MIXEDBUTTONS 8
#define TBSTYLE_EX_HIDECLIPPEDBUTTONS 16
#endif /* _WIN32_IE >= 0x0501 */
#if (_WIN32_WINNT >= 0x0501)
#define TBSTYLE_EX_DOUBLEBUFFER	0x80
#endif /* _WIN32_WINNT >= 0x0501 */
#if (_WIN32_IE >= 0x0500)
#define BTNS_BUTTON	TBSTYLE_BUTTON
#define BTNS_SEP	TBSTYLE_SEP
#define BTNS_CHECK	TBSTYLE_CHECK
#define BTNS_GROUP	TBSTYLE_GROUP
#define BTNS_CHECKGROUP	TBSTYLE_CHECKGROUP
#define BTNS_DROPDOWN	TBSTYLE_DROPDOWN
#define BTNS_AUTOSIZE	TBSTYLE_AUTOSIZE
#define BTNS_NOPREFIX	TBSTYLE_NOPREFIX
#define BTNS_WHOLEDROPDOWN	0x0080
#endif  /* _WIN32_IE >= 0x0500 */
#if _WIN32_IE >= 0x0501
#define BTNS_SHOWTEXT	0x0040
#endif
#if (_WIN32_IE >= 0x0400)
#define TBCDRF_NOEDGES	0x10000
#define TBCDRF_HILITEHOTTRACK	0x20000
#define TBCDRF_NOOFFSET	0x40000
#define TBCDRF_NOMARK	0x80000
#define TBCDRF_NOETCHEDEFFECT	0x100000
#endif /* _WIN32_IE >= 0x0400 */
#define HINST_COMMCTRL	((HINSTANCE)-1)
#define IDB_STD_SMALL_COLOR	0
#define IDB_STD_LARGE_COLOR	1
#define IDB_VIEW_SMALL_COLOR	4
#define IDB_VIEW_LARGE_COLOR	5
#if (_WIN32_IE >= 0x0300)
#define IDB_HIST_SMALL_COLOR	8
#define IDB_HIST_LARGE_COLOR	9
#endif
#define STD_CUT	0
#define STD_COPY	1
#define STD_PASTE	2
#define STD_UNDO	3
#define STD_REDOW	4
#define STD_DELETE	5
#define STD_FILENEW	6
#define STD_FILEOPEN	7
#define STD_FILESAVE	8
#define STD_PRINTPRE	9
#define STD_PROPERTIES	10
#define STD_HELP	11
#define STD_FIND	12
#define STD_REPLACE	13
#define STD_PRINT	14
#define VIEW_LARGEICONS	0
#define VIEW_SMALLICONS	1
#define VIEW_LIST	2
#define VIEW_DETAILS	3
#define VIEW_SORTNAME	4
#define VIEW_SORTSIZE	5
#define VIEW_SORTDATE	6
#define VIEW_SORTTYPE	7
#define VIEW_PARENTFOLDER	8
#define VIEW_NETCONNECT	9
#define VIEW_NETDISCONNECT	10
#define VIEW_NEWFOLDER	11
#define TB_ENABLEBUTTON	(WM_USER+1)
#define TB_CHECKBUTTON	(WM_USER+2)
#define TB_PRESSBUTTON	(WM_USER+3)
#define TB_HIDEBUTTON	(WM_USER+4)
#define TB_INDETERMINATE	(WM_USER+5)
#if (_WIN32_IE >= 0x0400)
#define TB_MARKBUTTON           (WM_USER+6)
#endif
#define TB_ISBUTTONENABLED	(WM_USER+9)
#define TB_ISBUTTONCHECKED	(WM_USER+10)
#define TB_ISBUTTONPRESSED	(WM_USER+11)
#define TB_ISBUTTONHIDDEN	(WM_USER+12)
#define TB_ISBUTTONINDETERMINATE	(WM_USER+13)
#if (_WIN32_IE >= 0x0400)
#define TB_ISBUTTONHIGHLIGHTED	(WM_USER+14)
#endif
#define TB_SETSTATE	(WM_USER+17)
#define TB_GETSTATE	(WM_USER+18)
#define TB_ADDBITMAP	(WM_USER+19)
#if (_WIN32_IE >= 0x0400)
#define TB_ADDBUTTONSA	(WM_USER+20)
#define TB_INSERTBUTTONA	(WM_USER+21)
#else
#define TB_ADDBUTTONS	(WM_USER+20)
#define TB_INSERTBUTTON	(WM_USER+21)
#endif
#define TB_DELETEBUTTON	(WM_USER+22)
#define TB_GETBUTTON	(WM_USER+23)
#define TB_BUTTONCOUNT	(WM_USER+24)
#define TB_COMMANDTOINDEX	(WM_USER+25)
#define TB_SAVERESTOREA	(WM_USER+26)
#define TB_SAVERESTOREW	(WM_USER+76)
#define TB_CUSTOMIZE	(WM_USER+27)
#define TB_ADDSTRINGA	(WM_USER+28)
#define TB_ADDSTRINGW	(WM_USER+77)
#define TB_GETITEMRECT	(WM_USER+29)
#define TB_BUTTONSTRUCTSIZE	(WM_USER+30)
#define TB_SETBUTTONSIZE	(WM_USER+31)
#define TB_SETBITMAPSIZE	(WM_USER+32)
#define TB_AUTOSIZE	(WM_USER+33)
#define TB_GETTOOLTIPS	(WM_USER+35)
#define TB_SETTOOLTIPS	(WM_USER+36)
#define TB_SETPARENT	(WM_USER+37)
#define TB_SETROWS	(WM_USER+39)
#define TB_GETROWS	(WM_USER+40)
#define TB_GETBITMAPFLAGS	(WM_USER+41)
#define TB_SETCMDID	(WM_USER+42)
#define TB_CHANGEBITMAP	(WM_USER+43)
#define TB_GETBITMAP	(WM_USER+44)
#define TB_GETBUTTONTEXTA	(WM_USER+45)
#define TB_GETBUTTONTEXTW	(WM_USER+75)
#define TB_REPLACEBITMAP	(WM_USER+46)
#define TB_GETBUTTONSIZE	(WM_USER+58)
#define TB_SETBUTTONWIDTH	(WM_USER+59)
#if (_WIN32_IE >= 0x0300)
#define TB_SETINDENT	(WM_USER+47)
#define TB_SETIMAGELIST	(WM_USER+48)
#define TB_GETIMAGELIST	(WM_USER+49)
#define TB_LOADIMAGES	(WM_USER+50)
#define TB_GETRECT	(WM_USER+51)
#define TB_SETHOTIMAGELIST	(WM_USER+52)
#define TB_GETHOTIMAGELIST	(WM_USER+53)
#define TB_SETDISABLEDIMAGELIST (WM_USER+54)
#define TB_GETDISABLEDIMAGELIST	(WM_USER+55)
#define TB_SETSTYLE	(WM_USER+56)
#define TB_GETSTYLE	(WM_USER+57)
#define TB_GETBUTTONSIZE	(WM_USER+58)
#define TB_SETBUTTONWIDTH	(WM_USER+59)
#define TB_SETMAXTEXTROWS	(WM_USER+60)
#define TB_GETTEXTROWS	(WM_USER+61)
#endif
#if _WIN32_IE >= 0x400
#define TB_GETOBJECT	(WM_USER+62)
#define TB_GETBUTTONINFOW	(WM_USER+63)
#define TB_SETBUTTONINFOW	(WM_USER+64)
#define TB_GETBUTTONINFOA	(WM_USER+65)
#define TB_SETBUTTONINFOA	(WM_USER+66)
#define TB_INSERTBUTTONW	(WM_USER+67)
#define TB_ADDBUTTONSW	(WM_USER+68)
#define TB_HITTEST	(WM_USER+69)
#define TB_SETEXTENDEDSTYLE	(WM_USER+84)
#define TB_GETEXTENDEDSTYLE	(WM_USER+85)
#define TB_SETDRAWTEXTFLAGS	(WM_USER+70)
#define TB_GETHOTITEM	(WM_USER+71)
#define TB_SETHOTITEM	(WM_USER+72)
#define TB_SETANCHORHIGHLIGHT	(WM_USER+73)
#define TB_GETANCHORHIGHLIGHT	(WM_USER+74)
#define TB_MAPACCELERATORA	(WM_USER+78)
#define TB_GETINSERTMARK	(WM_USER+79)
#define TB_SETINSERTMARK	(WM_USER+80)
#define TB_INSERTMARKHITTEST	(WM_USER+81)
#define TB_MOVEBUTTON		(WM_USER+82)
#define TB_GETMAXSIZE		(WM_USER+83)
#define TB_SETEXTENDEDSTYLE	(WM_USER+84)
#define TB_GETEXTENDEDSTYLE	(WM_USER+85)
#define TB_GETPADDING		(WM_USER+86)
#define TB_SETPADDING		(WM_USER+87)
#define TB_SETINSERTMARKCOLOR	(WM_USER+88)
#define TB_GETINSERTMARKCOLOR	(WM_USER+89)
#define TB_MAPACCELERATORW	(WM_USER+90)
#define TB_GETSTRINGW		(WM_USER+91)
#define TB_GETSTRINGA		(WM_USER+92)
#define TB_SETCOLORSCHEME	CCM_SETCOLORSCHEME
#define TB_GETCOLORSCHEME	CCM_GETCOLORSCHEME
#define TB_SETUNICODEFORMAT	CCM_SETUNICODEFORMAT
#define TB_GETUNICODEFORMAT	CCM_GETUNICODEFORMAT
#endif
#define TBBF_LARGE 1
#define TBN_GETBUTTONINFOA	(TBN_FIRST-0)
#define TBN_BEGINDRAG	(TBN_FIRST-1)
#define TBN_ENDDRAG	(TBN_FIRST-2)
#define TBN_BEGINADJUST	(TBN_FIRST-3)
#define TBN_ENDADJUST	(TBN_FIRST-4)
#define TBN_RESET	(TBN_FIRST-5)
#define TBN_QUERYINSERT	(TBN_FIRST-6)
#define TBN_QUERYDELETE	(TBN_FIRST-7)
#define TBN_TOOLBARCHANGE	(TBN_FIRST-8)
#define TBN_CUSTHELP	(TBN_FIRST-9)
#if (_WIN32_IE >= 0x0300)
#define TBN_DROPDOWN	(TBN_FIRST-10)
#endif
#if (_WIN32_IE >= 0x0400)
#define TBN_HOTITEMCHANGE	(TBN_FIRST-13)
#define TBN_DRAGOUT	(TBN_FIRST-14)
#define TBN_DELETINGBUTTON	(TBN_FIRST-15)
#define TBN_GETDISPINFOA	(TBN_FIRST-16)
#define TBN_GETDISPINFOW	(TBN_FIRST-17)
#define TBN_GETINFOTIPA	(TBN_FIRST-18)
#define TBN_GETINFOTIPW	(TBN_FIRST-19)
#define TBN_GETBUTTONINFOW	(TBN_FIRST-20)
#endif
#if (_WIN32_IE >= 0x0500)
#define TBN_RESTORE	(TBN_FIRST-21)
#define TBN_SAVE	(TBN_FIRST-22)
#define TBN_INITCUSTOMIZE	(TBN_FIRST-23)
#define TBNRF_HIDEHELP	1
#define TBNRF_ENDCUSTOMIZE	2
#define TBNF_IMAGE	1
#define TBNF_TEXT	2
#define TBNF_DI_SETITEM	0x10000000
#endif /* _WIN32_IE >= 0x0500 */
#define TTS_ALWAYSTIP	1
#define TTS_NOPREFIX	2
#if( _WIN32_IE >= 0x0500 )
#define TTS_NOANIMATE	0x10
#define TTS_NOFADE	0x20
#define TTS_BALLOON	0x40
#define TTS_CLOSE	0x80
#endif /* _WIN32_IE >= 0x0500 */
#define TTF_IDISHWND	1
#define TTF_CENTERTIP	2
#define TTF_RTLREADING	4
#define TTF_SUBCLASS	16
#if (_WIN32_IE >= 0x0300)
#define TTF_TRACK 0x0020
#define TTF_ABSOLUTE 0x0080
#define TTF_TRANSPARENT 0x0100
#if (_WIN32_IE >= 0x0501)
#define TTF_PARSELINKS 0x1000
#endif
#define TTF_DI_SETITEM 0x8000
#define TBCD_TICS 1
#define TBCD_THUMB 2
#define TBCD_CHANNEL 3
#endif /* _WIN32_IE >= 0x0300 */
#if (_WIN32_IE >= 0x0400)
#define TBDDRET_DEFAULT 0
#define TBDDRET_NODEFAULT 1
#define TBDDRET_TREATPRESSED 2
#define TBIMHT_AFTER 1
#define TBIMHT_BACKGROUND 2
#endif
#define TTDT_AUTOMATIC	0
#define TTDT_RESHOW	1
#define TTDT_AUTOPOP	2
#define TTDT_INITIAL	3
#define TTM_ACTIVATE	(WM_USER+1)
#define TTM_SETDELAYTIME	(WM_USER+3)
#define TTM_ADDTOOLA	(WM_USER+4)
#define TTM_ADDTOOLW	(WM_USER+50)
#define TTM_DELTOOLA	(WM_USER+5)
#define TTM_DELTOOLW	(WM_USER+51)
#define TTM_NEWTOOLRECTA	(WM_USER+6)
#define TTM_NEWTOOLRECTW	(WM_USER+52)
#define TTM_RELAYEVENT	(WM_USER+7)
#define TTM_GETTOOLINFOA	(WM_USER+8)
#define TTM_GETTOOLINFOW	(WM_USER+53)
#define TTM_SETTOOLINFOA	(WM_USER+9)
#define TTM_SETTOOLINFOW	(WM_USER+54)
#define TTM_HITTESTA	(WM_USER+10)
#define TTM_HITTESTW	(WM_USER+55)
#define TTM_GETTEXTA	(WM_USER+11)
#define TTM_GETTEXTW	(WM_USER+56)
#define TTM_UPDATETIPTEXTA	(WM_USER+12)
#define TTM_UPDATETIPTEXTW	(WM_USER+57)
#define TTM_GETTOOLCOUNT	(WM_USER+13)
#define TTM_ENUMTOOLSA	(WM_USER+14)
#define TTM_ENUMTOOLSW	(WM_USER+58)
#define TTM_GETCURRENTTOOLA	(WM_USER+15)
#define TTM_GETCURRENTTOOLW	(WM_USER+59)
#define TTM_WINDOWFROMPOINT	(WM_USER+16)
#if (_WIN32_IE >= 0x0300)
#define TTM_TRACKACTIVATE	  (WM_USER+17)  
#define TTM_TRACKPOSITION	  (WM_USER+18)  
#define TTM_SETTIPBKCOLOR	  (WM_USER+19)
#define TTM_SETTIPTEXTCOLOR	(WM_USER+20)
#define TTM_GETDELAYTIME	   (WM_USER+21)
#define TTM_GETTIPBKCOLOR	  (WM_USER+22)
#define TTM_GETTIPTEXTCOLOR	(WM_USER+23)
#define TTM_SETMAXTIPWIDTH	 (WM_USER+24)
#define TTM_GETMAXTIPWIDTH	 (WM_USER+25)
#define TTM_SETMARGIN		 (WM_USER+26)  
#define TTM_GETMARGIN		 (WM_USER+27)  
#define TTM_POP			  (WM_USER+28)
#endif /* _WIN32_IE */
#if (_WIN32_IE >= 0x0400)			/* IE4.0 ??? */
#define TTM_UPDATE		    (WM_USER+29)
#define TTM_GETBUBBLESIZE	(WM_USER+30)
#define TTM_ADJUSTRECT	(WM_USER+31)
#define TTM_SETTITLEA	(WM_USER+32)
#define TTM_SETTITLEW	(WM_USER+33)
#endif
#define TTN_GETDISPINFOA    (TTN_FIRST - 0)
#define TTN_GETDISPINFOW    (TTN_FIRST - 10)
#define TTN_NEEDTEXTA	TTN_GETDISPINFOA
#define TTN_NEEDTEXTW	TTN_GETDISPINFOW
#define TTN_SHOW	(TTN_FIRST-1)
#define TTN_POP	(TTN_FIRST-2)
#define UD_MAXVAL	0x7fff
#define UD_MINVAL	(-UD_MAXVAL)
#define UDN_DELTAPOS (UDN_FIRST-1)
#define UDS_WRAP	1
#define UDS_SETBUDDYINT	2
#define UDS_ALIGNRIGHT	4
#define UDS_ALIGNLEFT	8
#define UDS_AUTOBUDDY	16
#define UDS_ARROWKEYS	32
#define UDS_HORZ	64
#define UDS_NOTHOUSANDS	128
#if ( _WIN32_IE >= 0x0300 )
#define UDS_HOTTRACK	0x0100
#endif /* _WIN32_IE >= 0x0300 */
#define UDM_SETRANGE	(WM_USER+101)
#define UDM_GETRANGE	(WM_USER+102)
#define UDM_SETPOS	(WM_USER+103)
#define UDM_GETPOS	(WM_USER+104)
#define UDM_SETBUDDY	(WM_USER+105)
#define UDM_GETBUDDY	(WM_USER+106)
#define UDM_SETACCEL	(WM_USER+107)
#define UDM_GETACCEL	(WM_USER+108)
#define UDM_SETBASE	(WM_USER+109)
#define UDM_GETBASE	(WM_USER+110)
#if (_WIN32_IE >= 0x0400)
#define UDM_SETRANGE32	(WM_USER+111)
#define UDM_GETRANGE32	(WM_USER+112)
#define UDM_SETPOS32	(WM_USER+113)
#define UDM_GETPOS32	(WM_USER+114)
#endif
#if (_WIN32_IE >= 0x0500)
#define UDM_SETUNICODEFORMAT	CCM_SETUNICODEFORMAT
#define UDM_GETUNICODEFORMAT	CCM_GETUNICODEFORMAT
#endif
#define SB_SETTEXTA	(WM_USER+1)
#define SB_SETTEXTW	(WM_USER+11)
#define SB_GETTEXTA	(WM_USER+2)
#define SB_GETTEXTW	(WM_USER+13)
#define SB_GETTEXTLENGTHA	(WM_USER+3)
#define SB_GETTEXTLENGTHW	(WM_USER+12)
#define SB_SETPARTS	(WM_USER+4)
#define SB_GETPARTS	(WM_USER+6)
#define SB_GETBORDERS	(WM_USER+7)
#define SB_SETMINHEIGHT	(WM_USER+8)
#define SB_SIMPLE	(WM_USER+9)
#define SB_GETRECT	(WM_USER+10)
#define SBT_OWNERDRAW	0x1000
#define SBT_NOBORDERS	256
#define SBT_POPOUT	512
#define SBT_RTLREADING	1024
#if( _WIN32_IE >= 0x0400 )
#define SBT_TOOLTIPS	0x0800
#define SBN_SIMPLEMODECHANGE	(SBN_FIRST)
#endif /* _WIN32_IE >= 0x0400 */
#define TBS_AUTOTICKS	1
#define TBS_VERT	2
#define TBS_HORZ	0
#define TBS_TOP	4
#define TBS_BOTTOM	0
#define TBS_LEFT	4
#define TBS_RIGHT	0
#define TBS_BOTH	8
#define TBS_NOTICKS	16
#define TBS_ENABLESELRANGE	32
#define TBS_FIXEDLENGTH	64
#define TBS_NOTHUMB	128
#if (_WIN32_IE >= 0x0300)
#define TBS_TOOLTIPS 0x0100
#define TBTS_TOP 0
#define TBTS_LEFT 1
#define TBTS_BOTTOM 2
#define TBTS_RIGHT 3
#endif
#if (_WIN32_IE >= 0x0500)
#define TBS_REVERSED 0x0200
#endif
#if (_WIN32_IE >= 0x0501)
#define TBS_DOWNISLEFT 0x0400
#endif
#if _WIN32_IE >= 0x400
#define TBIF_BYINDEX 0x80000000
#define TBIF_COMMAND 32
#define TBIF_IMAGE 1
#define TBIF_LPARAM 16
#define TBIF_SIZE 64
#define TBIF_STATE 4
#define TBIF_STYLE 8
#define TBIF_TEXT 2
#endif
#define TBM_GETPOS	(WM_USER)
#define TBM_GETRANGEMIN	(WM_USER+1)
#define TBM_GETRANGEMAX	(WM_USER+2)
#define TBM_GETTIC	(WM_USER+3)
#define TBM_SETTIC	(WM_USER+4)
#define TBM_SETPOS	(WM_USER+5)
#define TBM_SETRANGE	(WM_USER+6)
#define TBM_SETRANGEMIN	(WM_USER+7)
#define TBM_SETRANGEMAX	(WM_USER+8)
#define TBM_CLEARTICS	(WM_USER+9)
#define TBM_SETSEL	(WM_USER+10)
#define TBM_SETSELSTART	(WM_USER+11)
#define TBM_SETSELEND	(WM_USER+12)
#define TBM_GETPTICS	(WM_USER+14)
#define TBM_GETTICPOS	(WM_USER+15)
#define TBM_GETNUMTICS	(WM_USER+16)
#define TBM_GETSELSTART	(WM_USER+17)
#define TBM_GETSELEND	(WM_USER+18)
#define TBM_CLEARSEL	(WM_USER+19)
#define TBM_SETTICFREQ	(WM_USER+20)
#define TBM_SETPAGESIZE	(WM_USER+21)
#define TBM_GETPAGESIZE	(WM_USER+22)
#define TBM_SETLINESIZE	(WM_USER+23)
#define TBM_GETLINESIZE	(WM_USER+24)
#define TBM_GETTHUMBRECT	(WM_USER+25)
#define TBM_GETCHANNELRECT	(WM_USER+26)
#define TBM_SETTHUMBLENGTH	(WM_USER+27)
#define TBM_GETTHUMBLENGTH	(WM_USER+28)
#define TBM_SETTOOLTIPS	(WM_USER+29)
#define TBM_GETTOOLTIPS	(WM_USER+30)
#define TBM_SETTIPSIDE	(WM_USER+31)
#define TBM_SETBUDDY	(WM_USER+32)
#define TBM_GETBUDDY	(WM_USER+33)
#define TBM_GETUNICODEFORMAT	CCM_GETUNICODEFORMAT 
#define TBM_SETUNICODEFORMAT	CCM_SETUNICODEFORMAT
#define TB_LINEUP	0
#define TB_LINEDOWN	1
#define TB_PAGEUP	2
#define TB_PAGEDOWN	3
#define TB_THUMBPOSITION	4
#define TB_THUMBTRACK	5
#define TB_TOP	6
#define TB_BOTTOM	7
#define TB_ENDTRACK	8
#define HOTKEYF_SHIFT	1
#define HOTKEYF_CONTROL	2
#define HOTKEYF_ALT	4
#define HOTKEYF_EXT	8
#define HKCOMB_NONE	1
#define HKCOMB_S	2
#define HKCOMB_C	4
#define HKCOMB_A	8
#define HKCOMB_SC	16
#define HKCOMB_SA	32
#define HKCOMB_CA	64
#define HKCOMB_SCA	128
#define HKM_SETHOTKEY	(WM_USER+1)
#define HKM_GETHOTKEY	(WM_USER+2)
#define HKM_SETRULES	(WM_USER+3)
#define PBM_SETRANGE	(WM_USER+1)
#define PBM_SETPOS	(WM_USER+2)
#define PBM_DELTAPOS	(WM_USER+3)
#define PBM_SETSTEP	(WM_USER+4)
#define PBM_STEPIT	(WM_USER+5)
#define PBM_SETRANGE32	1030
#define PBM_GETRANGE	1031
#define PBM_GETPOS	1032
#define PBM_SETBARCOLOR	1033
#define PBM_SETBKCOLOR	CCM_SETBKCOLOR
#define PBS_SMOOTH	1
#define PBS_VERTICAL	4
#define LVS_ICON	0
#define LVS_REPORT	1
#define LVS_SMALLICON	2
#define LVS_LIST	3
#define LVS_TYPEMASK	3
#define LVS_SINGLESEL	4
#define LVS_SHOWSELALWAYS	8
#define LVS_SORTASCENDING	16
#define LVS_SORTDESCENDING	32
#define LVS_SHAREIMAGELISTS	64
#define LVS_NOLABELWRAP	128
#define LVS_AUTOARRANGE	256
#define LVS_EDITLABELS	512
#define LVS_NOSCROLL	0x2000
#define LVS_TYPESTYLEMASK	0xfc00
#define LVS_ALIGNTOP	0
#define LVS_ALIGNLEFT	0x800
#define LVS_ALIGNMASK	0xc00
#define LVS_OWNERDRAWFIXED	0x400
#define LVS_NOCOLUMNHEADER	0x4000
#define LVS_NOSORTHEADER	0x8000
#if (_WIN32_IE >= 0x0300)
#define CDIS_CHECKED 8
#define CDIS_DEFAULT 32
#define CDIS_DISABLED 4
#define CDIS_FOCUS 16
#define CDIS_GRAYED 2
#define CDIS_HOT 64
#define CDIS_SELECTED 1
#define CDIS_MARKED 128
#define CDIS_INDETERMINATE 256
#if (_WIN32_WINNT >= 0x0501)
#define CDIS_SHOWKEYBOARDCUES 512
#endif
#define CDDS_POSTERASE 4
#define CDDS_POSTPAINT 2
#define CDDS_PREERASE 3
#define CDDS_PREPAINT 1
#define CDDS_ITEM 65536
#define CDDS_ITEMPOSTERASE 65540
#define CDDS_ITEMPOSTPAINT 65538
#define CDDS_ITEMPREERASE 65539
#define CDDS_ITEMPREPAINT 65537
#if (_WIN32_IE >= 0x0400)
#define CDDS_SUBITEM 0x20000
#endif
#define CDRF_DODEFAULT 0x00
#define CDRF_NOTIFYITEMDRAW 0x20
#define CDRF_NOTIFYSUBITEMDRAW 0x20
#define CDRF_NOTIFYITEMERASE 0x80
#define CDRF_NOTIFYPOSTERASE 0x40
#define CDRF_NOTIFYPOSTPAINT 0x10
#define CDRF_NEWFONT 0x02
#define CDRF_SKIPDEFAULT 0x04
#if (_WIN32_IE >= 0x0400)
#define LVBKIF_SOURCE_NONE      0x00000000
#define LVBKIF_SOURCE_HBITMAP   0x00000001
#define LVBKIF_SOURCE_URL       0x00000002
#define LVBKIF_SOURCE_MASK      0x00000003
#define LVBKIF_STYLE_NORMAL     0x00000000
#define LVBKIF_STYLE_TILE       0x00000010
#define LVBKIF_STYLE_MASK       0x00000010
#endif /* _WIN32_IE >=0x0400 */
#if (_WIN32_WINNT >= 0x501)
#define LVBKIF_FLAG_TILEOFFSET  0x00000100
#define LVBKIF_TYPE_WATERMARK   0x10000000
#endif /* _WIN32_WINNT >= 0x501 */
#define LVS_OWNERDATA 4096
#define LVS_EX_CHECKBOXES 4
#define LVS_EX_FULLROWSELECT 32
#define LVS_EX_GRIDLINES 1
#define LVS_EX_HEADERDRAGDROP 16
#define LVS_EX_ONECLICKACTIVATE 64
#define LVS_EX_SUBITEMIMAGES 2
#define LVS_EX_TRACKSELECT 8
#define LVS_EX_TWOCLICKACTIVATE 128
#define LVSICF_NOINVALIDATEALL	0x00000001
#define LVSICF_NOSCROLL	0x00000002
#if( _WIN32_IE >= 0x0400 )
#define LVS_EX_FLATSB	0x00000100
#define LVS_EX_REGIONAL	0x00000200
#define LVS_EX_INFOTIP	0x00000400
#define LVS_EX_UNDERLINEHOT	0x00000800
#define LVS_EX_UNDERLINECOLD	0x00001000
#define LVS_EX_MULTIWORKAREAS	0x00002000
#endif /* _WIN32_IE >=0x0400 */
#if( _WIN32_IE >= 0x0500 )
#define LVS_EX_LABELTIP	0x00004000
#define LVS_EX_BORDERSELECT	0x00008000
#endif  /* _WIN32_IE >= 0x0500 */
#endif  /* _WIN32_IE >= 0x0300 */
#define LVSIL_NORMAL	0
#define LVSIL_SMALL	1
#define LVSIL_STATE	2
#define LVM_GETBKCOLOR	LVM_FIRST
#define LVM_SETBKCOLOR	(LVM_FIRST+1)
#define LVM_GETIMAGELIST	(LVM_FIRST+2)
#define LVM_SETIMAGELIST	(LVM_FIRST+3)
#define LVM_GETITEMCOUNT	(LVM_FIRST+4)
#define LVM_SORTITEMSEX		(LVM_FIRST+81)
#if (_WIN32_WINNT >= 0x501)
#define LVM_SETSELECTEDCOLUMN	(LVM_FIRST+140)
#endif
#define LVM_SETVIEW		(LVM_FIRST+142)
#define LVM_GETVIEW		(LVM_FIRST+143)
#define LVM_INSERTGROUP		(LVM_FIRST+145)
#define LVM_SETGROUPINFO	(LVM_FIRST+147)
#define LVM_GETGROUPINFO	(LVM_FIRST+149)
#define LVM_REMOVEGROUP		(LVM_FIRST+150)
#define LVM_MOVEGROUP		(LVM_FIRST+151)
#define LVM_SETGROUPMETRICS	(LVM_FIRST+155)
#define LVM_GETGROUPMETRICS	(LVM_FIRST+156)
#define LVM_ENABLEGROUPVIEW	(LVM_FIRST+157)
#define LVM_SORTGROUPS		(LVM_FIRST+158)
#define LVM_INSERTGROUPSORTED	(LVM_FIRST+159)
#define LVM_REMOVEALLGROUPS	(LVM_FIRST+160)
#define LVM_HASGROUP		(LVM_FIRST+161)
#define LVM_SETTILEVIEWINFO	(LVM_FIRST+162)
#define LVM_GETTILEVIEWINFO	(LVM_FIRST+163)
#define LVM_SETTILEINFO		(LVM_FIRST+164)
#define LVM_GETTILEINFO		(LVM_FIRST+165)
#define LVM_SETINSERTMARK	(LVM_FIRST+166)
#define LVM_GETINSERTMARK	(LVM_FIRST+167)
#define LVM_INSERTMARKHITTEST	(LVM_FIRST+168)
#define LVM_GETINSERTMARKRECT	(LVM_FIRST+169)
#define LVM_SETINSERTMARKCOLOR	(LVM_FIRST+170)
#define LVM_GETINSERTMARKCOLOR	(LVM_FIRST+171)
#define LVM_SETINFOTIP		(LVM_FIRST+173)
#define LVM_GETSELECTEDCOLUMN	(LVM_FIRST+174)
#define LVM_ISGROUPVIEWENABLED	(LVM_FIRST+175)
#define LVM_GETOUTLINECOLOR	(LVM_FIRST+176)
#define LVM_SETOUTLINECOLOR	(LVM_FIRST+177)
#define LVM_CANCELEDITLABEL	(LVM_FIRST+179)
#define LVM_MAPIDTOINDEX	(LVM_FIRST+181)
#define LVIF_TEXT	1
#define LVIF_IMAGE	2
#define LVIF_PARAM	4
#define LVIF_STATE	8
#if (_WIN32_IE >= 0x0300)
#define LVIF_INDENT 16
#define LVIF_NORECOMPUTE 2048
#endif
#if (_WIN32_WINNT >= 0x0501)
#define LVIF_GROUPID 128
#define LVIF_COLUMNS 256
#endif
#define LVIS_FOCUSED	1
#define LVIS_SELECTED	2
#define LVIS_CUT	4
#define LVIS_DROPHILITED	8
#define LVIS_OVERLAYMASK	0xF00
#define LVIS_STATEIMAGEMASK	0xF000
#define LPSTR_TEXTCALLBACKW	((LPWSTR)-1)
#define LPSTR_TEXTCALLBACKA	((LPSTR)-1)
#define I_IMAGECALLBACK	(-1)
#define LVM_GETITEMA	(LVM_FIRST+5)
#define LVM_GETITEMW	(LVM_FIRST+75)
#define LVM_SETITEMA	(LVM_FIRST+6)
#define LVM_SETITEMW	(LVM_FIRST+76)
#define LVM_INSERTITEMA	(LVM_FIRST+7)
#define LVM_INSERTITEMW	(LVM_FIRST+77)
#define LVM_DELETEITEM	(LVM_FIRST+8)
#define LVM_DELETEALLITEMS	(LVM_FIRST+9)
#define LVM_GETCALLBACKMASK	(LVM_FIRST+10)
#define LVM_SETCALLBACKMASK	(LVM_FIRST+11)
#if( _WIN32_IE >= 0x0400 )
#define LVM_SETBKIMAGEA	(LVM_FIRST + 68)
#define LVM_SETBKIMAGEW	(LVM_FIRST + 138)
#define LVM_GETBKIMAGEA	(LVM_FIRST + 69)
#define LVM_GETBKIMAGEW	(LVM_FIRST + 139)
#define LV_MAX_WORKAREAS	16
#define LVM_SETWORKAREAS	(LVM_FIRST+65)
#define LVM_GETWORKAREAS	(LVM_FIRST+70)
#define LVM_GETNUMBEROFWORKAREAS	(LVM_FIRST+73)
#define LVM_GETSELECTIONMARK	(LVM_FIRST+66)
#define LVM_SETSELECTIONMARK	(LVM_FIRST+67)
#define LVM_SETHOVERTIME	(LVM_FIRST+71)
#define LVM_GETHOVERTIME	(LVM_FIRST+72)
#define LVM_SETTOOLTIPS	(LVM_FIRST+74)
#define LVM_GETTOOLTIPS	(LVM_FIRST+78)
#define LVM_SETUNICODEFORMAT CCM_SETUNICODEFORMAT
#define LVM_GETUNICODEFORMAT CCM_GETUNICODEFORMAT
#endif /* _WIN32_IE >= 0x0400 */
#define LVNI_ALL	0
#define LVNI_FOCUSED	1
#define LVNI_SELECTED	2
#define LVNI_CUT	4
#define LVNI_DROPHILITED	8
#define LVNI_ABOVE	256
#define LVNI_BELOW	512
#define LVNI_TOLEFT	1024
#define LVNI_TORIGHT	2048
#define LVM_GETNEXTITEM	(LVM_FIRST+12)
#define LVFI_PARAM	1
#define LVFI_STRING	2
#define LVFI_PARTIAL	8
#define LVFI_WRAP	32
#define LVFI_NEARESTXY	64
#define LVIF_DI_SETITEM	0x1000
#define LVM_FINDITEMA	(LVM_FIRST+13)
#define LVM_FINDITEMW	(LVM_FIRST+83)
#define LVIR_BOUNDS	0
#define LVIR_ICON	1
#define LVIR_LABEL	2
#define LVIR_SELECTBOUNDS	3
#define LVM_GETITEMRECT	(LVM_FIRST+14)
#define LVM_SETITEMPOSITION	(LVM_FIRST+15)
#define LVM_GETITEMPOSITION	(LVM_FIRST+16)
#define LVM_GETSTRINGWIDTHA	(LVM_FIRST+17)
#define LVM_GETSTRINGWIDTHW	(LVM_FIRST+87)
#define LVHT_NOWHERE	1
#define LVHT_ONITEMICON	2
#define LVHT_ONITEMLABEL	4
#define LVHT_ONITEMSTATEICON	8
#define LVHT_ONITEM	(LVHT_ONITEMICON|LVHT_ONITEMLABEL|LVHT_ONITEMSTATEICON)
#define LVHT_ABOVE	8
#define LVHT_BELOW	16
#define LVHT_TORIGHT	32
#define LVHT_TOLEFT	64
#define LVM_HITTEST	(LVM_FIRST+18)
#define LVM_ENSUREVISIBLE	(LVM_FIRST+19)
#define LVM_SCROLL	(LVM_FIRST+20)
#define LVM_REDRAWITEMS	(LVM_FIRST+21)
#define LVA_DEFAULT	0
#define LVA_ALIGNLEFT	1
#define LVA_ALIGNTOP	2
#define LVA_SNAPTOGRID	5
#define LVM_ARRANGE	(LVM_FIRST+22)
#define LVM_EDITLABELA	(LVM_FIRST+23)
#define LVM_EDITLABELW	(LVM_FIRST+118)
#define LVM_GETEDITCONTROL	(LVM_FIRST+24)
#define LVCF_FMT	1
#define LVCF_WIDTH	2
#define LVCF_TEXT	4
#define LVCF_SUBITEM	8
#if (_WIN32_IE >= 0x0300)
#define LVCF_IMAGE 16
#define LVCF_ORDER 32
#endif
#define LVCFMT_LEFT	0
#define LVCFMT_RIGHT	1
#define LVCFMT_CENTER	2
#define LVCFMT_JUSTIFYMASK	3
#if (_WIN32_IE >= 0x0300)
#define LVCFMT_BITMAP_ON_RIGHT 4096
#define LVCFMT_COL_HAS_IMAGES  32768
#define LVCFMT_IMAGE 2048 
#endif
#define LVM_GETCOLUMNA	(LVM_FIRST+25)
#define LVM_GETCOLUMNW	(LVM_FIRST+95)
#define LVM_SETCOLUMNA	(LVM_FIRST+26)
#define LVM_SETCOLUMNW	(LVM_FIRST+96)
#define LVM_INSERTCOLUMNA	(LVM_FIRST+27)
#define LVM_INSERTCOLUMNW	(LVM_FIRST+97)
#define LVM_DELETECOLUMN	(LVM_FIRST+28)
#define LVM_GETCOLUMNWIDTH	(LVM_FIRST+29)
#define LVSCW_AUTOSIZE	(-1)
#define LVSCW_AUTOSIZE_USEHEADER	(-2)
#define LVM_SETCOLUMNWIDTH	(LVM_FIRST+30)
#define LVM_CREATEDRAGIMAGE	(LVM_FIRST+33)
#define LVM_GETVIEWRECT	(LVM_FIRST+34)
#define LVM_GETTEXTCOLOR	(LVM_FIRST+35)
#define LVM_SETTEXTCOLOR	(LVM_FIRST+36)
#define LVM_GETTEXTBKCOLOR	(LVM_FIRST+37)
#define LVM_SETTEXTBKCOLOR	(LVM_FIRST+38)
#define LVM_GETTOPINDEX	(LVM_FIRST+39)
#define LVM_GETCOUNTPERPAGE	(LVM_FIRST+40)
#define LVM_GETORIGIN	(LVM_FIRST+41)
#define LVM_GETORIGIN	(LVM_FIRST+41)
#define LVM_UPDATE	(LVM_FIRST+42)
#define LVM_SETITEMSTATE	(LVM_FIRST+43)
#define LVM_GETITEMSTATE	(LVM_FIRST+44)
#define LVM_GETITEMTEXTA	(LVM_FIRST+45)
#define LVM_GETITEMTEXTW	(LVM_FIRST+115)
#define LVM_SETITEMTEXTA	(LVM_FIRST+46)
#define LVM_SETITEMTEXTW	(LVM_FIRST+116)
#define LVM_SETITEMCOUNT	(LVM_FIRST+47)
#define LVM_SORTITEMS	(LVM_FIRST+48)
#define LVM_SETITEMPOSITION32	(LVM_FIRST+49)
#define LVM_GETSELECTEDCOUNT	(LVM_FIRST+50)
#define LVM_GETITEMSPACING	(LVM_FIRST+51)
#define LVM_GETISEARCHSTRINGA	(LVM_FIRST+52)
#define LVM_GETISEARCHSTRINGW	(LVM_FIRST+117)
#if (_WIN32_IE >= 0x0300)
#define LVM_APPROXIMATEVIEWRECT (LVM_FIRST+64)
#define LVM_SETEXTENDEDLISTVIEWSTYLE (LVM_FIRST+54)
#define LVM_GETEXTENDEDLISTVIEWSTYLE (LVM_FIRST+55)
#define LVM_SETCOLUMNORDERARRAY (LVM_FIRST+58)
#define LVM_GETCOLUMNORDERARRAY (LVM_FIRST+59)
#define LVM_GETHEADER (LVM_FIRST+31)
#define LVM_GETHOTCURSOR (LVM_FIRST+63)
#define LVM_GETHOTITEM (LVM_FIRST+61)
#define LVM_GETSUBITEMRECT (LVM_FIRST+56)
#define LVM_SETHOTCURSOR (LVM_FIRST+62)
#define LVM_SETHOTITEM (LVM_FIRST+60)
#define LVM_SETICONSPACING (LVM_FIRST+53)
#define LVM_SUBITEMHITTEST (LVM_FIRST+57)
#endif
#define LVN_ITEMCHANGING	LVN_FIRST
#define LVN_ITEMCHANGED	(LVN_FIRST-1)
#define LVN_INSERTITEM	(LVN_FIRST-2)
#define LVN_DELETEITEM	(LVN_FIRST-3)
#define LVN_DELETEALLITEMS	(LVN_FIRST-4)
#define LVN_BEGINLABELEDITA	(LVN_FIRST-5)
#define LVN_BEGINLABELEDITW	(LVN_FIRST-75)
#define LVN_ENDLABELEDITA	(LVN_FIRST-6)
#define LVN_ENDLABELEDITW	(LVN_FIRST-76)
#define LVN_COLUMNCLICK	(LVN_FIRST-8)
#define LVN_BEGINDRAG	(LVN_FIRST-9)
#define LVN_BEGINRDRAG	(LVN_FIRST-11)
#define LVN_GETDISPINFOA	(LVN_FIRST-50)
#define LVN_GETDISPINFOW	(LVN_FIRST-77)
#define LVN_SETDISPINFOA	(LVN_FIRST-51)
#define LVN_SETDISPINFOW	(LVN_FIRST-78)
#define LVN_KEYDOWN	(LVN_FIRST-55)
#if (_WIN32_IE >= 0x0400)
#define LVN_MARQUEEBEGIN  (LVN_FIRST-56)
#define LVN_GETINFOTIPA	(LVN_FIRST-57)
#define LVN_GETINFOTIPW	(LVN_FIRST-58)
#define LVKF_ALT	0x0001
#define LVKF_CONTROL	0x0002
#define LVKF_SHIFT	0x0004
#define LVGIT_UNFOLDED  1
#endif
#define TVS_HASBUTTONS	1
#define TVS_HASLINES	2
#define TVS_LINESATROOT	4
#define TVS_EDITLABELS	8
#define TVS_DISABLEDRAGDROP	16
#define TVS_SHOWSELALWAYS	32
#if (_WIN32_IE >= 0x0300)
#define TVS_CHECKBOXES 256
#define TVS_NOTOOLTIPS 128
#define TVS_RTLREADING 64
#define TVS_TRACKSELECT 512
#endif
#if (_WIN32_IE >= 0x0400)
#define TVS_FULLROWSELECT 4096
#define TVS_INFOTIP 2048
#define TVS_NONEVENHEIGHT 16384
#define TVS_NOSCROLL 8192
#define TVS_SINGLEEXPAND 1024
#endif
#if( _WIN32_IE >= 0x0500 )
#define TVS_NOHSCROLL	0x8000
#endif /* _WIN32_IE >= 0x0500 */
#define TVIF_TEXT	1
#define TVIF_IMAGE	2
#define TVIF_PARAM	4
#define TVIF_STATE	8
#define TVIF_HANDLE	16
#define TVIF_SELECTEDIMAGE	32
#define TVIF_CHILDREN	64
#if (_WIN32_IE >= 0x0400)
#define TVIF_INTEGRAL	0x0080
#endif /* _WIN32_IE >= 0x0400 */
#define TVIS_FOCUSED	1
#define TVIS_SELECTED	2
#define TVIS_CUT	4
#define TVIS_DROPHILITED	8
#define TVIS_BOLD	16
#define TVIS_EXPANDED	32
#define TVIS_EXPANDEDONCE	64
#define TVIS_OVERLAYMASK	0xF00
#define TVIS_STATEIMAGEMASK	0xF000
#define TVIS_USERMASK	0xF000
#define I_CHILDRENCALLBACK	(-1)
#define TVI_ROOT	((HTREEITEM)0xFFFF0000)
#define TVI_FIRST	((HTREEITEM)0xFFFF0001)
#define TVI_LAST	((HTREEITEM)0xFFFF0002)
#define TVI_SORT	((HTREEITEM)0xFFFF0003)
#define TVSIL_NORMAL	0
#define TVSIL_STATE	2
#define TVM_INSERTITEMA	TV_FIRST
#define TVM_INSERTITEMW	(TV_FIRST+50)
#define TVM_DELETEITEM	(TV_FIRST+1)
#define TVM_EXPAND	(TV_FIRST+2)
#define TVM_GETITEMRECT	(TV_FIRST+4)
#define TVM_GETCOUNT	(TV_FIRST+5)
#define TVM_GETINDENT	(TV_FIRST+6)
#define TVM_SETINDENT	(TV_FIRST+7)
#define TVM_GETIMAGELIST	(TV_FIRST+8)
#define TVM_SETIMAGELIST	(TV_FIRST+9)
#define TVM_GETNEXTITEM	(TV_FIRST+10)
#define TVM_SELECTITEM	(TV_FIRST+11)
#define TVM_GETITEMA	(TV_FIRST+12)
#define TVM_GETITEMW	(TV_FIRST+62)
#define TVM_SETITEMA	(TV_FIRST+13)
#define TVM_SETITEMW	(TV_FIRST+63)
#define TVM_EDITLABELA	(TV_FIRST+14)
#define TVM_EDITLABELW	(TV_FIRST+65)
#define TVM_GETEDITCONTROL	(TV_FIRST+15)
#define TVM_GETVISIBLECOUNT	(TV_FIRST+16)
#define TVM_HITTEST	(TV_FIRST+17)
#define TVM_CREATEDRAGIMAGE	(TV_FIRST+18)
#define TVM_SORTCHILDREN	(TV_FIRST+19)
#define TVM_ENSUREVISIBLE	(TV_FIRST+20)
#define TVM_SORTCHILDRENCB	(TV_FIRST+21)
#define TVM_ENDEDITLABELNOW	(TV_FIRST+22)
#define TVM_GETISEARCHSTRINGA	(TV_FIRST+23)
#define TVM_GETISEARCHSTRINGW	(TV_FIRST+64)
#if (_WIN32_IE >= 0x0300)
#define TVM_GETTOOLTIPS (TV_FIRST+25)
#define TVM_SETTOOLTIPS (TV_FIRST+24)
#endif
#if (_WIN32_IE >= 0x0400)
#define TVM_GETBKCOLOR (TV_FIRST+31)
#define TVM_GETINSERTMARKCOLOR (TV_FIRST+38)
#define TVM_GETITEMHEIGHT (TV_FIRST+28)
#define TVM_GETSCROLLTIME (TV_FIRST+34)
#define TVM_GETTEXTCOLOR (TV_FIRST+32)
#define TVM_SETBKCOLOR (TV_FIRST+29)
#define TVM_SETINSERTMARK (TV_FIRST+26)
#define TVM_SETINSERTMARKCOLOR (TV_FIRST+37)
#define TVM_SETITEMHEIGHT (TV_FIRST+27)
#define TVM_SETSCROLLTIME (TV_FIRST+33)
#define TVM_SETTEXTCOLOR (TV_FIRST+30)
#define TVM_SETUNICODEFORMAT CCM_SETUNICODEFORMAT
#define TVM_GETUNICODEFORMAT CCM_GETUNICODEFORMAT
#endif
#if (_WIN32_IE >= 0x0500)
#define TVM_GETITEMSTATE (TV_FIRST+39)
#define TVM_SETLINECOLOR (TV_FIRST+40)
#define TVM_GETLINECOLOR (TV_FIRST+41)
#endif
#define TVE_COLLAPSE	1
#define TVE_EXPAND	2
#define TVE_TOGGLE	3
#define TVE_COLLAPSERESET	0x8000
#if (_WIN32_IE >= 0x0300)
#define TVE_EXPANDPARTIAL	0x4000
#endif
#define TVC_UNKNOWN	0
#define TVC_BYMOUSE	1
#define TVC_BYKEYBOARD	2
#define TVGN_ROOT	0
#define TVGN_NEXT	1
#define TVGN_PREVIOUS	2
#define TVGN_PARENT	3
#define TVGN_CHILD	4
#define TVGN_FIRSTVISIBLE	5
#define TVGN_NEXTVISIBLE	6
#define TVGN_PREVIOUSVISIBLE	7
#define TVGN_DROPHILITE	8
#define TVGN_CARET	9
#if (_WIN32_IE >= 0x0400)
#define TVGN_LASTVISIBLE	10
#endif
#define TVN_SELCHANGINGA	(TVN_FIRST-1)
#define TVN_SELCHANGINGW	(TVN_FIRST-50)
#define TVN_SELCHANGEDA	(TVN_FIRST-2)
#define TVN_SELCHANGEDW	(TVN_FIRST-51)
#define TVN_GETDISPINFOA	(TVN_FIRST-3)
#define TVN_GETDISPINFOW	(TVN_FIRST-52)
#define TVN_SETDISPINFOA	(TVN_FIRST-4)
#define TVN_SETDISPINFOW	(TVN_FIRST-53)
#define TVN_ITEMEXPANDINGA	(TVN_FIRST-5)
#define TVN_ITEMEXPANDINGW	(TVN_FIRST-54)
#define TVN_ITEMEXPANDEDA	(TVN_FIRST-6)
#define TVN_ITEMEXPANDEDW	(TVN_FIRST-55)
#define TVN_BEGINDRAGA	(TVN_FIRST-7)
#define TVN_BEGINDRAGW	(TVN_FIRST-56)
#define TVN_BEGINRDRAGA	(TVN_FIRST-8)
#define TVN_BEGINRDRAGW	(TVN_FIRST-57)
#define TVN_DELETEITEMA	(TVN_FIRST-9)
#define TVN_DELETEITEMW	(TVN_FIRST-58)
#define TVN_BEGINLABELEDITA	(TVN_FIRST-10)
#define TVN_BEGINLABELEDITW	(TVN_FIRST-59)
#define TVN_ENDLABELEDITA	(TVN_FIRST-11)
#define TVN_ENDLABELEDITW	(TVN_FIRST-60)
#define TVN_KEYDOWN	(TVN_FIRST-12)
#if (_WIN32_IE >= 0x0400)
#define TVN_GETINFOTIPA	(TVN_FIRST-13)
#define TVN_GETINFOTIPW	(TVN_FIRST-14)
#define TVN_SINGLEEXPAND	(TVN_FIRST-15)
#define TVNRET_DEFAULT 0
#define TVNRET_SKIPOLD 1
#define TVNRET_SKIPNEW 2
#endif /* _WIN32_IE >= 0x0400 */
#define TVIF_DI_SETITEM	0x1000
#define TVHT_NOWHERE	1
#define TVHT_ONITEMICON	2
#define TVHT_ONITEMLABEL	4
#define TVHT_ONITEM	(TVHT_ONITEMICON|TVHT_ONITEMLABEL|TVHT_ONITEMSTATEICON)
#define TVHT_ONITEMINDENT	8
#define TVHT_ONITEMBUTTON	16
#define TVHT_ONITEMRIGHT	32
#define TVHT_ONITEMSTATEICON	64
#define TVHT_ABOVE	256
#define TVHT_BELOW	512
#define TVHT_TORIGHT	1024
#define TVHT_TOLEFT	2048
#define TCHT_NOWHERE	1
#define TCHT_ONITEMICON	2
#define TCHT_ONITEMLABEL	4
#define TCHT_ONITEM	(TCHT_ONITEMICON|TCHT_ONITEMLABEL)
#define TCS_FORCEICONLEFT	16
#define TCS_FORCELABELLEFT	32
#define TCS_TABS	0
#define TCS_BUTTONS	256
#define TCS_SINGLELINE	0
#define TCS_MULTILINE	512
#define TCS_RIGHTJUSTIFY	0
#define TCS_FIXEDWIDTH	1024
#define TCS_RAGGEDRIGHT	2048
#define TCS_FOCUSONBUTTONDOWN	0x1000
#define TCS_OWNERDRAWFIXED	0x2000
#define TCS_TOOLTIPS	0x4000
#define TCS_FOCUSNEVER	0x8000
#if (_WIN32_IE >= 0x0300)
#define TCS_BOTTOM	2
#define TCS_RIGHT	2
#define TCS_VERTICAL	128
#define TCS_SCROLLOPPOSITE	0x0001
#define TCS_HOTTRACK	0x0040
#define TCS_MULTISELECT	0x0004
#endif
#if( _WIN32_IE >= 0x0400 )
#define TCS_FLATBUTTONS	0x0008
#define TCS_EX_FLATSEPARATORS	0x00000001
#define TCS_EX_REGISTERDROP	0x00000002
#endif /* _WIN32_IE >= 0x0400 */
#define TCIF_TEXT	1
#define TCIF_IMAGE	2
#define TCIF_RTLREADING	4
#define TCIF_PARAM	8
#if (_WIN32_IE >= 0x0400)
#define TCIF_STATE	16
#endif
#define TCIS_BUTTONPRESSED 1
#if (_WIN32_IE >= 0x0400)
#define TCIS_HIGHLIGHTED 2
#endif
#define TCM_FIRST	0x1300
#define TCM_GETIMAGELIST	(TCM_FIRST+2)
#define TCM_SETIMAGELIST	(TCM_FIRST+3)
#define TCM_GETITEMCOUNT	(TCM_FIRST+4)
#define TCM_GETITEMA	(TCM_FIRST+5)
#define TCM_GETITEMW	(TCM_FIRST+60)
#define TCM_SETITEMA	(TCM_FIRST+6)
#define TCM_SETITEMW	(TCM_FIRST+61)
#define TCM_INSERTITEMA	(TCM_FIRST+7)
#define TCM_INSERTITEMW	(TCM_FIRST+62)
#define TCM_DELETEITEM	(TCM_FIRST+8)
#define TCM_DELETEALLITEMS	(TCM_FIRST+9)
#define TCM_GETITEMRECT	(TCM_FIRST+10)
#define TCM_GETCURSEL	(TCM_FIRST+11)
#define TCM_SETCURSEL	(TCM_FIRST+12)
#define TCM_HITTEST	(TCM_FIRST+13)
#define TCM_SETITEMEXTRA	(TCM_FIRST+14)

#define TCM_ADJUSTRECT	(TCM_FIRST+40)
#define TCM_SETITEMSIZE	(TCM_FIRST+41)
#define TCM_REMOVEIMAGE	(TCM_FIRST+42)
#define TCM_SETPADDING	(TCM_FIRST+43)
#define TCM_GETROWCOUNT	(TCM_FIRST+44)
#define TCM_GETTOOLTIPS	(TCM_FIRST+45)
#define TCM_SETTOOLTIPS	(TCM_FIRST+46)
#define TCM_GETCURFOCUS	(TCM_FIRST+47)
#define TCM_SETCURFOCUS	(TCM_FIRST+48)
#define TCM_SETMINTABWIDTH	(TCM_FIRST + 49)
#define TCM_DESELECTALL	(TCM_FIRST + 50)
#if (_WIN32_IE >=0x0400)
#define TCM_HIGHLIGHTITEM	(TCM_FIRST + 51)
#define TCM_SETEXTENDEDSTYLE	(TCM_FIRST + 52)
#define TCM_GETEXTENDEDSTYLE	(TCM_FIRST + 53)
#define TCM_SETUNICODEFORMAT	CCM_SETUNICODEFORMAT
#define TCM_GETUNICODEFORMAT	CCM_GETUNICODEFORMAT
#endif /* _WIN32_IE >=0x0400 */
#define TCN_KEYDOWN	TCN_FIRST
#define TCN_SELCHANGE	(TCN_FIRST-1)
#define TCN_SELCHANGING	(TCN_FIRST-2)
#define NM_OUTOFMEMORY (NM_FIRST-1)
#define NM_CLICK (NM_FIRST-2)
#define NM_DBLCLK (NM_FIRST-3)
#define NM_RETURN (NM_FIRST-4)
#define NM_RCLICK (NM_FIRST-5)
#define NM_RDBLCLK (NM_FIRST-6)
#define NM_SETFOCUS (NM_FIRST-7)
#define NM_KILLFOCUS (NM_FIRST-8)
#define NM_CUSTOMDRAW (NM_FIRST-12)
#define NM_HOVER (NM_FIRST-13)
#define NM_NCHITTEST (NM_FIRST-14)
#define NM_KEYDOWN (NM_FIRST-15)
#define NM_RELEASEDCAPTURE (NM_FIRST-16)
#define NM_SETCURSOR (NM_FIRST-17)
#define NM_CHAR (NM_FIRST-18)
#define NM_TOOLTIPSCREATED (NM_FIRST-19)
#define SBARS_SIZEGRIP 256
#define CCM_FIRST 0x2000
#define CCM_LAST (CCM_FIRST+0x200)
#define CCM_SETBKCOLOR 8193
#define CCM_SETCOLORSCHEME 8194
#define CCM_GETCOLORSCHEME 8195
#define CCM_GETDROPTARGET 8196
#define CCM_SETUNICODEFORMAT 8197
#define CCM_GETUNICODEFORMAT 8198
#define CCM_SETVERSION 0x2007
#define CCM_GETVERSION 0x2008
#define CCM_SETNOTIFYWINDOW 0x2009
#if (_WIN32_WINNT >= 0x0501)
#define CCM_SETWINDOWTHEME 0x200b
#define CCM_DPISCALE 0x200c
#endif 
#define ICC_LISTVIEW_CLASSES 1
#define ICC_TREEVIEW_CLASSES 2
#define ICC_BAR_CLASSES	4
#define ICC_TAB_CLASSES      8
#define ICC_UPDOWN_CLASS 16
#define ICC_PROGRESS_CLASS 32
#define ICC_HOTKEY_CLASS 64
#define ICC_ANIMATE_CLASS 128
#define ICC_WIN95_CLASSES 255
#define ICC_DATE_CLASSES 256
#define ICC_USEREX_CLASSES 512
#define ICC_COOL_CLASSES 1024
#if (_WIN32_IE >= 0x0400)
#define ICC_INTERNET_CLASSES 2048
#define ICC_PAGESCROLLER_CLASS 4096
#define ICC_NATIVEFNTCTL_CLASS 8192
#define INFOTIPSIZE 1024
#endif /* _WIN32_IE */
#if (_WIN32_WINNT >= 0x501)
#define ICC_STANDARD_CLASSES	0x00004000
#define ICC_LINK_CLASS		0x00008000
#endif
#define GDTR_MIN 1
#define GDTR_MAX 2
#define GMR_VISIBLE 0
#define GMR_DAYSTATE 1
#define GDT_ERROR -1
#define GDT_VALID 0
#define GDT_NONE 1
#define DTS_UPDOWN 1
#define DTS_SHOWNONE 2
#define DTS_SHORTDATEFORMAT 0
#define DTS_LONGDATEFORMAT 4
#define DTS_TIMEFORMAT 9
#define DTS_APPCANPARSE 16
#define DTS_RIGHTALIGN 32
#if ( _WIN32_IE >= 0x500 )
#define DTS_SHORTDATECENTURYFORMAT	0x000C
#endif /* _WIN32_IE >= 0x500 */
#define MCS_DAYSTATE 1
#define MCS_MULTISELECT 2
#define MCS_WEEKNUMBERS 4
#if (_WIN32_IE >= 0x0400)
#define MCS_NOTODAYCIRCLE	0x0008
#define MCS_NOTODAY	0x0010
#else /* _WIN32_IE >= 0x0400 */
#define MCS_NOTODAY	0x0008
#endif /* _WIN32_IE >= 0x0400 */
#define DTM_GETSYSTEMTIME 0x1001
#define DTM_SETSYSTEMTIME 0x1002
#define DTM_GETRANGE 0x1003
#define DTM_SETRANGE 0x1004
#define DTM_SETFORMATA 0x1005
#define DTM_SETFORMATW 0x1050
#define DTM_SETMCCOLOR 0x1006
#define DTM_GETMCCOLOR 0x1007
#define DTM_GETMONTHCAL 0x1008
#define DTM_SETMCFONT	0x1009
#define DTM_GETMCFONT	0x100a
#define DTN_USERSTRINGA  ((UINT)-758)
#define DTN_USERSTRINGW  ((UINT)-745)
#define DTN_WMKEYDOWNA  ((UINT)-757)
#define DTN_WMKEYDOWNW  ((UINT)-744)
#define DTN_FORMATA  ((UINT)-756) 
#define DTN_FORMATW  ((UINT)-743)
#define DTN_FORMATQUERYA  ((UINT)-755) 
#define DTN_FORMATQUERYW ((UINT)-742)
#define DTN_DROPDOWN    ((UINT)-754) 
#define DTN_CLOSEUP	((UINT)-753) 
#define DTN_DATETIMECHANGE ((UINT)-759) 
#define MCM_GETCURSEL	0x1001
#define MCM_SETCURSEL	0x1002
#define MCM_GETMAXSELCOUNT 0x1003
#define MCM_SETMAXSELCOUNT 0x1004
#define MCM_GETSELRANGE	0x1005
#define MCM_SETSELRANGE	0x1006
#define MCM_GETMONTHRANGE 0x1007
#define MCM_SETDAYSTATE	0x1008
#define MCM_GETMINREQRECT 0x1009
#define MCM_SETCOLOR 0x100a
#define MCM_GETCOLOR 0x100b
#define MCM_SETTODAY 0x100c
#define MCM_GETTODAY 0x100d
#define MCM_HITTEST 0x100e
#define MCM_SETFIRSTDAYOFWEEK 0x100f
#define MCM_GETFIRSTDAYOFWEEK 0x1010
#define MCM_GETRANGE 0x1011
#define MCM_SETRANGE 0x1012
#define MCM_GETMONTHDELTA 0x1013
#define MCM_SETMONTHDELTA 0x1014
#define MCM_GETMAXTODAYWIDTH 0x1015
#define MCM_GETUNICODEFORMAT CCM_GETUNICODEFORMAT
#define MCM_SETUNICODEFORMAT CCM_SETUNICODEFORMAT
#define MCN_SELCHANGE	  ((UINT)-749)
#define MCN_GETDAYSTATE	((UINT)-747)
#define MCN_SELECT		((UINT)-746)
#define ODT_HEADER 100
#define ODT_TAB 101
#define ODT_LISTVIEW 102
#define SB_SETBKCOLOR	0x2001
#if (_WIN32_IE >= 0x0300)
#define SB_ISSIMPLE 1038
#define MCSC_BACKGROUND 0
#define MCSC_TEXT 1
#define MCSC_TITLEBK 2
#define MCSC_TITLETEXT 3
#define MCSC_MONTHBK 4
#define MCSC_TRAILINGTEXT 5
#endif
#if (_WIN32_IE >= 0x0400)
#define MCHT_TITLE 0x10000
#define MCHT_CALENDAR 0x20000
#define MCHT_TODAYLINK 0x30000
#define MCHT_NEXT 0x1000000
#define MCHT_PREV 0x2000000
#define MCHT_NOWHERE 0x00
#define MCHT_TITLEBK (MCHT_TITLE)
#define MCHT_TITLEMONTH (MCHT_TITLE | 0x0001)
#define MCHT_TITLEYEAR (MCHT_TITLE | 0x0002)
#define MCHT_TITLEBTNNEXT (MCHT_TITLE | MCHT_NEXT | 0x0003)
#define MCHT_TITLEBTNPREV (MCHT_TITLE | MCHT_PREV | 0x0003)
#define MCHT_CALENDARBK (MCHT_CALENDAR)
#define MCHT_CALENDARDATE (MCHT_CALENDAR | 0x0001)
#define MCHT_CALENDARDATENEXT (MCHT_CALENDARDATE | MCHT_NEXT)
#define MCHT_CALENDARDATEPREV (MCHT_CALENDARDATE | MCHT_PREV)
#define MCHT_CALENDARDAY (MCHT_CALENDAR | 0x0002)
#define MCHT_CALENDARWEEKNUM (MCHT_CALENDAR | 0x0003)
#endif /* _WIN32_IE >= 0x0400 */
#define RBS_TOOLTIPS 256
#define RBS_VARHEIGHT 512
#define RBS_BANDBORDERS 1024
#define RBS_FIXEDORDER 2048
#define RBIM_IMAGELIST 1
#define RB_SETCOLORSCHEME CCM_SETCOLORSCHEME
#define RB_GETCOLORSCHEME CCM_GETCOLORSCHEME
#define RBBS_BREAK	0x0001
#define RBBS_FIXEDSIZE	0x0002
#define RBBS_CHILDEDGE	0x0004
#define RBBS_HIDDEN	0x0008
#define RBBS_NOVERT	0x0010
#define RBBS_FIXEDBMP	0x0020
#define RBBS_VARIABLEHEIGHT	0x0040
#define RBBS_GRIPPERALWAYS	0x0080
#define RBBS_NOGRIPPER	0x0100
#if (_WIN32_IE >= 0x0500)
#define RBBS_USECHEVRON	0x0200
#if (_WIN32_IE >= 0x0501)
#define RBBS_HIDETITLE	0x0400
#define RBBS_TOPALIGN	0x0800
#endif /* _WIN32_IE >= 0x0501 */
#endif /* _WIN32_IE >= 0x0500 */
#define RBBIM_STYLE 1
#define RBBIM_COLORS 2
#define RBBIM_TEXT 4
#define RBBIM_IMAGE 8
#define RBBIM_CHILD 16
#define RBBIM_CHILDSIZE 32
#define RBBIM_SIZE 64
#define RBBIM_BACKGROUND 128
#define RBBIM_ID 256
#define RB_INSERTBANDA (WM_USER+1)
#define RB_INSERTBANDW (WM_USER+10)
#define RB_DELETEBAND (WM_USER+2)
#define RB_GETBARINFO (WM_USER+3)
#define RB_SETBARINFO (WM_USER+4)
#define RB_GETBANDCOUNT (WM_USER+12)
#define RB_GETROWCOUNT (WM_USER+13)
#define RB_GETROWHEIGHT (WM_USER+14)
#define RB_SETBANDINFOA (WM_USER+6)
#define RB_SETBANDINFOW (WM_USER+11)
#define RB_SETPARENT (WM_USER+7)
#define RBN_HEIGHTCHANGE RBN_FIRST
#if (_WIN32_IE >= 0x0300)
#define LVN_ODCACHEHINT (LVN_FIRST-13)
#define LVN_ODFINDITEMA (LVN_FIRST-52)
#define LVN_ODFINDITEMW (LVN_FIRST-79)
#define LVN_ITEMACTIVATE (LVN_FIRST-14)
#define LVN_ODSTATECHANGED (LVN_FIRST-15)
#ifdef UNICODE
#define LVN_ODFINDITEM LVN_ODFINDITEMW
#else
#define LVN_ODFINDITEM LVN_ODFINDITEMA
#endif
#endif /* _WIN32_IE */
#if (_WIN32_IE >= 0x0400)
#define SB_SETICON 1039
#define SB_SETTIPTEXTA	1040
#define SB_SETTIPTEXTW	1041
#define SB_GETTIPTEXTA	1042
#define SB_GETTIPTEXTW	1043
#define SB_GETICON	1044
#define SB_SETUNICODEFORMAT	0x2005
#define SB_GETUNICODEFORMAT	0x2006
#define PGF_INVISIBLE 0
#define PGF_NORMAL 1
#define PGF_GRAYED 2
#define PGF_DEPRESSED 4
#define PGF_HOT 8
#define PGB_TOPORLEFT 0
#define PGB_BOTTOMORRIGHT 1
#define PGF_SCROLLUP 1
#define PGF_SCROLLDOWN 2
#define PGF_SCROLLLEFT 4
#define PGF_SCROLLRIGHT 8
#define PGK_SHIFT 1
#define PGK_CONTROL 2
#define PGK_MENU 4
#define PGF_CALCWIDTH 1
#define PGF_CALCHEIGHT 2
#define PGM_FIRST 0x1400
#define PGM_SETCHILD (PGM_FIRST+1)
#define PGM_RECALCSIZE (PGM_FIRST+2)
#define PGM_FORWARDMOUSE (PGM_FIRST+3)
#define PGM_SETBKCOLOR (PGM_FIRST+4)
#define PGM_GETBKCOLOR (PGM_FIRST+5)
#define PGM_SETBORDER (PGM_FIRST+6)
#define PGM_GETBORDER (PGM_FIRST+7)
#define PGM_SETPOS (PGM_FIRST+8)
#define PGM_GETPOS (PGM_FIRST+9)
#define PGM_SETBUTTONSIZE (PGM_FIRST+10)
#define PGM_GETBUTTONSIZE (PGM_FIRST+11)
#define PGM_GETBUTTONSTATE (PGM_FIRST+12)
#define PGM_GETDROPTARGET CCM_GETDROPTARGET
#define RBS_REGISTERDROP 4096
#define RBS_AUTOSIZE 8192
#define RBS_VERTICALGRIPPER 16384
#define RBS_DBLCLKTOGGLE  32768
#define RBBIM_IDEALSIZE 512
#define RBBIM_LPARAM 1024
#define RBBIM_HEADERSIZE 2048
#define RB_HITTEST (WM_USER+8)
#define RB_GETRECT (WM_USER+9)
#define RB_IDTOINDEX (WM_USER+16)
#define RB_GETTOOLTIPS (WM_USER+17)
#define RB_SETTOOLTIPS (WM_USER+18)
#define RB_SETBKCOLOR (WM_USER+19)
#define RB_GETBKCOLOR (WM_USER+20)
#define RB_SETTEXTCOLOR (WM_USER+21)
#define RB_GETTEXTCOLOR (WM_USER+22)
#define RB_SIZETORECT (WM_USER+23)
#define RB_BEGINDRAG (WM_USER+24)
#define RB_ENDDRAG (WM_USER+25)
#define RB_DRAGMOVE (WM_USER+26)
#define RB_GETBARHEIGHT (WM_USER+27)
#define RB_GETBANDINFOW (WM_USER+28)
#define RB_GETBANDINFOA (WM_USER+29)
#define RB_MINIMIZEBAND (WM_USER+30)
#define RB_MAXIMIZEBAND (WM_USER+31)
#define RB_GETDROPTARGET CCM_GETDROPTARGET
#define RB_GETBANDBORDERS (WM_USER+34)
#define RB_SHOWBAND (WM_USER+35)
#define RB_SETPALETTE (WM_USER+37)
#define RB_GETPALETTE (WM_USER+38)
#define RB_MOVEBAND (WM_USER+39)
#define RB_SETUNICODEFORMAT     CCM_SETUNICODEFORMAT
#define RB_GETUNICODEFORMAT     CCM_GETUNICODEFORMAT
#define RBN_GETOBJECT (RBN_FIRST-1)
#define RBN_LAYOUTCHANGED (RBN_FIRST-2)
#define RBN_AUTOSIZE (RBN_FIRST-3)
#define RBN_BEGINDRAG (RBN_FIRST-4)
#define RBN_ENDDRAG (RBN_FIRST-5)
#define RBN_DELETINGBAND (RBN_FIRST-6)
#define RBN_DELETEDBAND (RBN_FIRST-7)
#define RBN_CHILDSIZE (RBN_FIRST-8)
#define RBNM_ID 1
#define RBNM_STYLE 2
#define RBNM_LPARAM 4
#define RBHT_NOWHERE 1
#define RBHT_CAPTION 2
#define RBHT_CLIENT 3
#define RBHT_GRABBER 4
#ifdef UNICODE
#define SB_SETTIPTEXT	SB_SETTIPTEXTW
#define SB_GETTIPTEXT	SB_GETTIPTEXTW
#define RB_GETBANDINFO	RB_GETBANDINFOW
#else
#define SB_SETTIPTEXT	SB_SETTIPTEXTA
#define SB_GETTIPTEXT	SB_GETTIPTEXTA
#define RB_GETBANDINFO	RB_GETBANDINFOA
#endif
#else
#define RB_GETBANDINFO (WM_USER+5)
#endif /* _WIN32_IE >= 0x0400 */
#define CBEM_INSERTITEMA	(WM_USER + 1)
#define CBEM_SETIMAGELIST	(WM_USER + 2)
#define CBEM_GETIMAGELIST	(WM_USER + 3)
#define CBEM_GETITEMA	(WM_USER + 4)
#define CBEM_SETITEMA	(WM_USER + 5)
#define CBEM_DELETEITEM	CB_DELETESTRING
#define CBEM_GETCOMBOCONTROL	(WM_USER + 6)
#define CBEM_GETEDITCONTROL	(WM_USER + 7)
#define CBEM_SETEXSTYLE	(WM_USER + 8)
#define CBEM_GETEXSTYLE	(WM_USER + 9)
#if (_WIN32_IE >= 0x0400)
#define CBEM_SETEXTENDEDSTYLE	(WM_USER + 14)
#define CBEM_GETEXTENDEDSTYLE	(WM_USER + 9)
#define CBEM_SETUNICODEFORMAT	CCM_SETUNICODEFORMAT
#define CBEM_GETUNICODEFORMAT	CCM_GETUNICODEFORMAT
#endif /* _WIN32_IE >= 0x0400 */
#define CBEM_HASEDITCHANGED	(WM_USER + 10)
#define CBEM_INSERTITEMW	(WM_USER + 11)
#define CBEM_SETITEMW	(WM_USER + 12)
#define CBEM_GETITEMW	(WM_USER + 13)
#define DA_LAST	0x7fffffff
#define DPA_APPEND	0x7fffffff
#define DPA_ERR	-1
#define DSA_APPEND	0x7fffffff
#define DSA_ERR	-1
#define DPAS_SORTED	1
#define DPAS_INSERTBEFORE	2
#define DPAS_INSERTAFTER	4
#if (_WIN32_IE >= 0x400)
#define WSB_PROP_CYVSCROLL	1
#define WSB_PROP_CXHSCROLL	2
#define WSB_PROP_CYHSCROLL	4
#define WSB_PROP_CXVSCROLL	8
#define WSB_PROP_CXHTHUMB	16
#define WSB_PROP_CYVTHUMB	32
#define WSB_PROP_VBKGCOLOR	64
#define WSB_PROP_HBKGCOLOR	128
#define WSB_PROP_VSTYLE	256
#define WSB_PROP_HSTYLE	512
#define WSB_PROP_WINSTYLE	1024
#define WSB_PROP_PALETTE	2048
#define WSB_PROP_MASK	0xfff
#define FSB_FLAT_MODE	2
#define FSB_ENCARTA_MODE	1
#define FSB_REGULAR_MODE	0
#endif /* _WIN32_IE >= 0x400 */
#if (_WIN32_WINNT >= 0x0501)
#define LIF_ITEMINDEX	0x00000001
#define LIF_STATE	0x00000002
#define LIF_ITEMID	0x00000004
#define LIF_URL	0x00000008
#define LIS_FOCUSED	0x00000001
#define LIS_ENABLED	0x00000002
#define LIS_VISITED	0x00000004
#define LM_HITTEST	(WM_USER + 768)
#define LM_GETIDEALHEIGHT	(WM_USER + 769)
#define LM_SETITEM	(WM_USER + 770)
#define LM_GETITEM	(WM_USER + 771)
#define MAX_LINKID_TEXT	48
#define L_MAX_URL_LENGTH	2084
#endif

// From afxpriv.h
/////////////////////////////////////////////////////////////////////////////
// Internal AFX Windows messages (see Technical note TN024 for more details)
// (0x0360 - 0x037F are reserved for MFC)

#define WM_QUERYAFXWNDPROC  0x0360  // lResult = 1 if processed by AfxWndProc
#define WM_SIZEPARENT       0x0361  // lParam = &AFX_SIZEPARENTPARAMS
#define WM_SETMESSAGESTRING 0x0362  // wParam = nIDS (or 0),
                                    // lParam = lpszOther (or NULL)
#define WM_IDLEUPDATECMDUI  0x0363  // wParam == bDisableIfNoHandler
#define WM_INITIALUPDATE    0x0364  // (params unused) - sent to children
#define WM_COMMANDHELP      0x0365  // lResult = TRUE/FALSE,
                                    // lParam = dwContext
#define WM_HELPHITTEST      0x0366  // lResult = dwContext,
                                    // lParam = MAKELONG(x,y)
#define WM_EXITHELPMODE     0x0367  // (params unused)
#define WM_RECALCPARENT     0x0368  // force RecalcLayout on frame window
                                    //  (only for inplace frame windows)
#define WM_SIZECHILD        0x0369  // special notify from COleResizeBar
                                    // wParam = ID of child window
                                    // lParam = lpRectNew (new position/size)
#define WM_KICKIDLE         0x036A  // (params unused) causes idles to kick in
#define WM_QUERYCENTERWND   0x036B  // lParam = HWND to use as centering parent
#define WM_DISABLEMODAL     0x036C  // lResult = 0, disable during modal state
                                    // lResult = 1, don't disable
#define WM_FLOATSTATUS      0x036D  // wParam combination of FS_* flags below

// WM_ACTIVATETOPLEVEL is like WM_ACTIVATEAPP but works with hierarchies
//   of mixed processes (as is the case with OLE in-place activation)
#define WM_ACTIVATETOPLEVEL 0x036E  // wParam = nState (like WM_ACTIVATE)
                                    // lParam = pointer to HWND[2]
                                    //  lParam[0] = hWnd getting WM_ACTIVATE
                                    //  lParam[1] = hWndOther

#define WM_QUERY3DCONTROLS  0x036F  // lResult != 0 if 3D controls wanted

// Note: Messages 0x0370, 0x0371, and 0x372 were incorrectly used by
//  some versions of Windows.  To remain compatible, MFC does not
//  use messages in that range.
#define WM_RESERVED_0370    0x0370
#define WM_RESERVED_0371    0x0371
#define WM_RESERVED_0372    0x0372

// WM_SOCKET_NOTIFY and WM_SOCKET_DEAD are used internally by MFC's
// Windows sockets implementation.  For more information, see sockcore.cpp
#define WM_SOCKET_NOTIFY    0x0373
#define WM_SOCKET_DEAD      0x0374

// same as WM_SETMESSAGESTRING except not popped if IsTracking()
#define WM_POPMESSAGESTRING 0x0375

// WM_HELPPROMPTADDR is used internally to get the address of
//  m_dwPromptContext from the associated frame window. This is used
//  during message boxes to setup for F1 help while that msg box is
//  displayed. lResult is the address of m_dwPromptContext.
#define WM_HELPPROMPTADDR   0x0376

// Constants used in DLGINIT resources for OLE control containers
// NOTE: These are NOT real Windows messages they are simply tags
// used in the control resource and are never used as 'messages'
#define WM_OCC_LOADFROMSTREAM           0x0376
#define WM_OCC_LOADFROMSTORAGE          0x0377
#define WM_OCC_INITNEW                  0x0378
#define WM_OCC_LOADFROMSTREAM_EX        0x037A
#define WM_OCC_LOADFROMSTORAGE_EX       0x037B

// Marker used while rearranging the message queue
#define WM_QUEUE_SENTINEL   0x0379

// Note: Messages 0x037C - 0x37E reserved for future MFC use.
#define WM_RESERVED_037C    0x037C
#define WM_RESERVED_037D    0x037D
#define WM_RESERVED_037E    0x037E

// WM_FORWARDMSG - used by ATL to forward a message to another window for processing
//  WPARAM - DWORD dwUserData - defined by user
//  LPARAM - LPMSG pMsg - a pointer to the MSG structure
//  return value - 0 if the message was not processed, nonzero if it was
#define WM_FORWARDMSG       0x037F

// Define resources here that are "hidden under the hood" of MFC...
enum
{
   __NEEDS_TO_FIT_IN_16_BITS_START = 0xE000,
   //   STRINGTABLE
   //   BEGIN
      ID_FILE_MRU_FILE1       ,
      ID_FILE_MRU_FILE2       ,
      ID_FILE_MRU_FILE3       ,
      ID_FILE_MRU_FILE4       ,
      ID_FILE_MRU_FILE5       ,
      ID_FILE_MRU_FILE6       ,
      ID_FILE_MRU_FILE7       ,
      ID_FILE_MRU_FILE8       ,
      ID_FILE_MRU_FILE9       ,
      ID_FILE_MRU_FILE10      ,
      ID_FILE_MRU_FILE11      ,
      ID_FILE_MRU_FILE12      ,
      ID_FILE_MRU_FILE13      ,
      ID_FILE_MRU_FILE14      ,
      ID_FILE_MRU_FILE15      ,
      ID_FILE_MRU_FILE16      ,
   //   END
   
   __UNDER_THE_HOOD_START = 0x8000000,

   AFX_IDS_ALLFILTER,
   AFX_IDS_OPENFILE,
   AFX_IDS_SAVEFILE,
   AFX_IDS_SAVEFILECOPY,
   AFX_IDS_UNTITLED,
   AFX_IDP_ASK_TO_SAVE,
   AFX_IDP_FAILED_TO_CREATE_DOC,

   IDC_STATIC,

   AFX_IDW_PANE_FIRST,
   AFX_IDW_STATUS_BAR,
   AFX_IDW_TOOLBAR,
   AFX_IDW_REBAR,

   ID_SEPARATOR,

//   STRINGTABLE
//   BEGIN
   AFX_IDS_APP_TITLE       ,
   AFX_IDS_IDLEMESSAGE     ,
   AFX_IDS_HELPMODEMESSAGE,
//   END

//   STRINGTABLE
//   BEGIN
   ID_INDICATOR_EXT        ,
   ID_INDICATOR_CAPS       ,
   ID_INDICATOR_NUM        ,
   ID_INDICATOR_SCRL       ,
   ID_INDICATOR_OVR        ,
   ID_INDICATOR_REC        ,
//   END

//   STRINGTABLE
//   BEGIN
   ID_FILE_NEW             ,
   ID_FILE_OPEN            ,
   ID_FILE_CLOSE           ,
   ID_FILE_SAVE            ,
   ID_FILE_SAVE_AS         ,
//   END

//   STRINGTABLE
//   BEGIN
   ID_APP_ABOUT            ,
   ID_APP_EXIT             ,
   ID_HELP_INDEX           ,
   ID_HELP_FINDER          ,
   ID_HELP_USING           ,
   ID_CONTEXT_HELP         ,
   ID_HELP                 ,
//   END

//   STRINGTABLE
//   BEGIN
   ID_NEXT_PANE            ,
   ID_PREV_PANE            ,
//   END

//   STRINGTABLE
//   BEGIN
   ID_WINDOW_SPLIT         ,
//   END

//   STRINGTABLE
//   BEGIN
   ID_EDIT_CLEAR           ,
   ID_EDIT_CLEAR_ALL       ,
   ID_EDIT_COPY            ,
   ID_EDIT_CUT             ,
   ID_EDIT_FIND            ,
   ID_EDIT_PASTE           ,
   ID_EDIT_REPEAT          ,
   ID_EDIT_REPLACE         ,
   ID_EDIT_SELECT_ALL      ,
   ID_EDIT_UNDO            ,
   ID_EDIT_REDO            ,
//   END

//   STRINGTABLE
//   BEGIN
   ID_VIEW_TOOLBAR         ,
   ID_VIEW_STATUS_BAR      ,
//   END

//   STRINGTABLE
//   BEGIN
   AFX_IDS_SCSIZE          ,
   AFX_IDS_SCMOVE          ,
   AFX_IDS_SCMINIMIZE      ,
   AFX_IDS_SCMAXIMIZE      ,
   AFX_IDS_SCNEXTWINDOW    ,
   AFX_IDS_SCPREVWINDOW    ,
   AFX_IDS_SCCLOSE         ,
//   END

//   STRINGTABLE
//   BEGIN
   AFX_IDS_SCRESTORE       ,
   AFX_IDS_SCTASKLIST      ,
//   END
};

// From wingdi.h
#define GRADIENT_FILL_RECT_H 0x00
#define GRADIENT_FILL_RECT_V 0x01
#define GRADIENT_FILL_TRIANGLE 0x02
#define GRADIENT_FILL_OP_FLAG 0xff

// Releasing pointers
#define SAFE_RELEASE(p) \
        if (p != NULL) { \
                delete p;       \
                p = NULL;       \
        }       \

#define SAFE_RELEASE_ARRAY(p) \
        if (p != NULL) { \
                delete [] p;    \
                p = NULL;       \
        }       \


#if defined(Q_OS_WIN32)
#define max(a,b) (((a) > (b)) ? (a) : (b))
#define min(a,b) (((a) > (b)) ? (b) : (a))
#endif

// workaround to force ignore ms_abi errors, not needed as long as we don't link with other mfc implementations
// also g++ doesn't have __has_attribute()
#if !defined(Q_OS_WIN) && !defined(Q_OS_WIN32) && !defined(__GNUC__) && !defined(__GNUG__)
#if !__has_attribute(ms_abi)
#define ms_abi
#endif
#endif

#include <windows.h>
#include <prsht.h>

#define stricmp strcasecmp

#if !defined(Q_OS_WIN32)
#define _MAX_PATH 256
#endif

// special struct for WM_SIZEPARENT
struct AFX_SIZEPARENTPARAMS
{
//    HDWP hDWP;       // handle for DeferWindowPos
    RECT rect;       // parent client rectangle (trim as appropriate)
    SIZE sizeTotal;  // total size on each side as layout proceeds
    BOOL bStretch;   // should stretch to fill all space
};

struct AFX_CTLCOLOR
{
	HWND hWnd;
	HDC hDC;
	UINT nCtlType;
};

struct AFX_NOTIFY
{
	LRESULT* pResult;
	NMHDR* pNMHDR;
};

#define ATL_MAKEINTRESOURCE(x) CString(QString::number(x))
#define MAKEINTRESOURCE(x) ATL_MAKEINTRESOURCE(x)

#if UNICODE
typedef LPCWSTR LPCTSTR;
typedef wchar_t TCHAR;
#define _T(x) L##x
#else
typedef LPCSTR LPCTSTR;
typedef char TCHAR;
#define _T(x) x
#endif
#if !defined(QT_NO_DEBUG)
#if !defined(TRACE0)
#define TRACE0(x) { QString str; str.sprintf("TRACE0: %s(%d): %s",__FILE__,__LINE__, (x)); qDebug(str.toLatin1().constData()); }
#endif
#if !defined(TRACE1)
#define TRACE1(x,y) { QString str; str.sprintf("TRACE2: %s(%d): %s",__FILE__,__LINE__, (x)); qDebug(str.toLatin1().constData()); }
#endif
#if !defined(TRACE2)
#define TRACE2(x,y,z) { QString str; str.sprintf("TRACE2: %s(%d): %s",__FILE__,__LINE__, (x)); qDebug(str.toLatin1().constData()); }
#endif
#if !defined(TRACE)
#define TRACE(x) { QString str; str.sprintf("TRACE0: %s(%d): %s",__FILE__,__LINE__, (x)); qDebug(str.toLatin1().constData()); }
#endif
#if !defined(ATLTRACE2)
#define ATLTRACE2(a,b,str,q...) qDebug(str,##q)
#endif
#else
#if !defined(TRACE0)
#define TRACE0(x)
#endif
#if !defined(TRACE1)
#define TRACE1(x,y)
#endif
#if !defined(TRACE2)
#define TRACE2(x,y,z)
#endif
#if !defined(TRACE0)
#define TRACE0(x)
#endif
#if !defined(TRACE)
#define TRACE(x)
#endif
#if !defined(ATLTRACE2)
#define ATLTRACE2(a,b,str,q...)
#endif
#endif
#define VERIFY(x) x
#define ENSURE(x) x

TCHAR* A2T(char* str);
char* T2A(TCHAR* str);

typedef int* POSITION;

#define afx_msg

#if UNICODE
#define _tcscpy_s(d,l,s) wcsncpy((char*)(d),(const char*)(s),(l))
#else
#define _tcscpy_s(d,l,s) strncpy((char*)(d),(const char*)(s),(l))
#endif
#define strcpy_s(d,l,s) strncpy((char*)(d),(const char*)(s),(l))
#define vsprintf_s(b,n,f,v) vsprintf((b),(f),(v))
#define _itot_s(n,s,l,b) snprintf(s,l,"%d",n) 
#if UNICODE
#define _ttoi _wtoi
#define _tstoi _wtoi
#define _tcslen wcslen
#define _tcscmp wcscmp
#define _tcsicmp wcsicmp
#define _stscanf wscanf
#define _stscanf_s wscanf
#else
#define _ttoi atoi
#define _tstoi atoi
#define _tcslen strlen
#define _tcscmp strcmp
#define _tcsicmp stricmp
#define _stscanf sscanf
#define _stscanf_s sscanf
#endif
#ifdef QT_NO_DEBUG
#define ASSERT(y)
#define ASSERT_VALID(y)
#define ASSERT_KINDOF(y,z)
#else
#define ASSERT(y) { if (!(y)) { QString str; str.sprintf("ASSERT: %s(%d)",__FILE__,__LINE__); qFatal(str.toLatin1().constData()); } }
#define ASSERT_VALID(y) { if (!(y)) { QString str; str.sprintf("ASSERT_VALID: %s(%d)",__FILE__,__LINE__); qFatal(str.toLatin1().constData()); } }
#define ASSERT_KINDOF(y,z) { if ( !dynamic_cast<y*>(z) ) { QString str; str.sprintf("ASSERT_KINDOF: %s(%d)",__FILE__,__LINE__); qFatal(str.toLatin1().constData()); } }
#endif

#define ENSURE_VALID(x)
#define ENSURE_ARG(x)
#define UNUSED(x)

#define GET_X_LPARAM(lp) LOWORD(lp)
#define GET_Y_LPARAM(lp) HIWORD(lp)

#define _huge

HCURSOR WINAPI SetCursor(
   HCURSOR hCursor
);

BOOL WINAPI GetWindowRect(
   HWND hWnd,
   LPRECT lpRect
);

UINT WINAPI RegisterClipboardFormat(
   LPCTSTR lpszFormat
);

DWORD WINAPI GetFileAttributes(
   LPCTSTR lpFileName
);

LONG WINAPI GetWindowLong(
   HWND hWnd,
   int nIndex
);

int WINAPI GetKeyNameText(
   LONG lParam,
   LPTSTR lpString,
   int cchSize
);

#if !defined(Q_OS_WIN32)
HMODULE WINAPI LoadLibrary(
   LPCTSTR lpFileName
);

FARPROC WINAPI GetProcAddress(
   HMODULE hModule,
   LPCSTR lpProcName
);

BOOL WINAPI FreeLibrary(
   HMODULE hModule
);
#endif

HANDLE WINAPI CreateEvent(
   LPSECURITY_ATTRIBUTES lpEventAttributes,
   BOOL bManualReset,
   BOOL bInitialState,
   LPCTSTR lpName
);

BOOL WINAPI SetEvent(
   HANDLE hEvent
);

BOOL WINAPI ResetEvent(
   HANDLE hEvent
);

BOOL WINAPI PulseEvent(
   HANDLE hEvent
);

BOOL WINAPI GetCursorPos(
   LPPOINT lpPoint
);

DWORD WINAPI GetModuleFileName(
   HMODULE hModule,
   LPTSTR lpFilename,
   DWORD nSize
);

BOOL WINAPI CopyFile(
   LPCTSTR lpExistingFileName,
   LPCTSTR lpNewFileName,
   BOOL bFailIfExists
);

BOOL PathRemoveFileSpec(
   LPTSTR pszPath
);

BOOL PathAppend(
   LPTSTR pszPath,
   LPCTSTR pszMore
);

int MulDiv(
  int nNumber,
  int nNumerator,
  int nDenominator
);

#if !defined(Q_OS_WIN32)
DWORD WINAPI GetTickCount(void);
#endif
DWORD WINAPI GetSysColor(
  int nIndex
);
int WINAPI GetSystemMetrics(
  int nIndex
);
SHORT WINAPI GetKeyState(
  int nVirtKey
);
BOOL WINAPI IsClipboardFormatAvailable(
  UINT format
);
BOOL WINAPI OpenClipboard(
//  HWND hWndNewOwner = 0
);
BOOL WINAPI EmptyClipboard(void);
BOOL WINAPI CloseClipboard(void);
HANDLE WINAPI SetClipboardData(
  UINT uFormat,
  HANDLE hMem
);
HANDLE WINAPI GetClipboardData(
  UINT uFormat
);

HGLOBAL WINAPI GlobalAlloc(
  UINT uFlags,
  SIZE_T dwBytes
);
LPVOID WINAPI GlobalLock(
  HGLOBAL hMem
);
BOOL WINAPI GlobalUnlock(
  HGLOBAL hMem
);
SIZE_T WINAPI GlobalSize(
  HGLOBAL hMem
);
HGLOBAL WINAPI GlobalFree(
   HGLOBAL hMem
);

extern ACCEL* _acceleratorTbl;

HACCEL WINAPI CreateAcceleratorTable(
  LPACCEL lpaccl,
  int cEntries
);

HACCEL WINAPI LoadAccelerators(
   HINSTANCE hInstance,
   LPCTSTR lpTableName
);

int WINAPI TranslateAccelerator(
  HWND hWnd,
  HACCEL hAccTable,
  LPMSG lpMsg
);

BOOL WINAPI DestroyAcceleratorTable(
  HACCEL hAccel
);

#define MAPVK_VK_TO_VSC    0
#define MAPVK_VSC_TO_VK    1
#define MAPVK_VK_TO_CHAR   2
#define MAPVK_VSC_TO_VK_EX 3

UINT WINAPI MapVirtualKey(
  UINT uCode,
  UINT uMapType
);

class CDumpContext
{
};

class CFrameWnd;
class CDocument;
struct CRuntimeClass;
class CDocTemplate;
class CCreateContext
{
public:
   CFrameWnd* m_pCurrentFrame;
	CDocument* m_pCurrentDoc;
	CRuntimeClass* m_pNewViewClass;
	CDocTemplate* m_pNewDocTemplate;
};

class CObject;
struct CRuntimeClass
{
   LPCSTR m_lpszClassName; // A null-terminated string containing the ASCII class name.
   int m_nObjectSize; // The size of the object, in bytes. If the object has data members that point to allocated memory, the size of that memory is not included.
   UINT m_wSchema; // The schema number ( \961 for nonserializable classes). See the IMPLEMENT_SERIAL macro for a description of the schema number.
   CObject* ( * m_pfnCreateObject )( ); // A function pointer to the default constructor that creates an object of your class (valid only if the class supports dynamic creation; otherwise, returns NULL).
   CRuntimeClass* ( PASCAL* m_pfn_GetBaseClass )( ); // If your application is dynamically linked to the AFXDLL version of MFC, a pointer to a function that returns the CRuntimeClass structure of the base class.
   CRuntimeClass* m_pBaseClass;
   CObject* CreateObject( );
};

#define RUNTIME_CLASS(class_name) (&class_name::class##class_name)

#define DECLARE_DYNCREATE(class_name) \
public: \
   CRuntimeClass* GetRuntimeClass(); \
   static CRuntimeClass class##class_name; \
   static CObject* CreateObject();  

#define IMPLEMENT_DYNCREATE(derived_class,base_class) \
   CRuntimeClass derived_class::class##derived_class = \
   { \
   #derived_class, \
   sizeof(derived_class), \
   -1, \
   &derived_class::CreateObject, \
   NULL, \
   RUNTIME_CLASS(base_class) \
   }; \
   \
   CObject* derived_class::CreateObject() \
   { \
       return new derived_class; \
   } \
   \
   CRuntimeClass* derived_class::GetRuntimeClass() \
   { \
      return &class##derived_class; \
   }

#define DECLARE_DYNAMIC(class_name) \
public: \
   CRuntimeClass* GetRuntimeClass(); \
   static CRuntimeClass class##class_name;

#define IMPLEMENT_DYNAMIC(derived_class,base_class) \
   CRuntimeClass derived_class::class##derived_class = \
   { \
   #derived_class, \
   sizeof(derived_class), \
   -1, \
   NULL, \
   NULL, \
   RUNTIME_CLASS(base_class) \
   }; \
   \
   CRuntimeClass* derived_class::GetRuntimeClass() \
   { \
      return &class##derived_class; \
   }

class CObject
{
public:
   DECLARE_DYNAMIC(CObject)
   CObject() {}
   virtual ~CObject() {}
   virtual void DeleteObject() {}
   virtual CRuntimeClass* GetRuntimeClass( ) const;
   BOOL IsKindOf( 
      const CRuntimeClass* pClass  
   ) const;
   
};

#define AFX_MSG_CALL

class CCmdTarget;
typedef struct
{
//   void( AFX_MSG_CALL CCmdTarget::* )( void ) 	pmf;
   CCmdTarget* 	pTarget;
} AFX_CMDHANDLERINFO;

struct AFX_MSGMAP_ENTRY;

struct AFX_MSGMAP
{
	const AFX_MSGMAP* (PASCAL* pfnGetBaseMap)();
	const AFX_MSGMAP_ENTRY* lpEntries;
};

#define DECLARE_MESSAGE_MAP() \
protected: \
	static const AFX_MSGMAP* PASCAL GetThisMessageMap(); \
	virtual const AFX_MSGMAP* GetMessageMap() const; \

#define BEGIN_MESSAGE_MAP(theClass, baseClass) \
   const AFX_MSGMAP* theClass::GetMessageMap() const \
		{ return GetThisMessageMap(); } \
   const AFX_MSGMAP* PASCAL theClass::GetThisMessageMap() \
	{ \
		typedef theClass ThisClass;						   \
		typedef baseClass TheBaseClass;					   \
		static const AFX_MSGMAP_ENTRY _messageEntries[] =  \
		{

#define END_MESSAGE_MAP() \
		{0, 0, 0, 0, AfxSig_end, (AFX_PMSG)0 } \
	}; \
		static const AFX_MSGMAP messageMap = \
   { &TheBaseClass::GetThisMessageMap, &_messageEntries[0] }; \
      return &messageMap; \
   }

class CMenu;
class CCmdTarget : public CObject
{
   DECLARE_DYNCREATE(CCmdTarget)
public:
      CCmdTarget() {}
   virtual ~CCmdTarget() {}
   virtual BOOL OnCmdMsg(
      UINT nID,
      int nCode,
      void* pExtra,
      AFX_CMDHANDLERINFO* pHandlerInfo
   );
   
   DECLARE_MESSAGE_MAP()
   
   afx_msg LRESULT OnMenuChar(UINT nChar, UINT nFlags, CMenu* pMenu) { return 0; }
};

typedef void (AFX_MSG_CALL CCmdTarget::*AFX_PMSG)(void);

struct AFX_MSGMAP_ENTRY  // MFC 4.0 format
{
  UINT nMessage; // windows message
  UINT nCode;    // control code or WM_NOTIFY code
  UINT nID;      // control ID (or 0 for windows messages)
  UINT nLastID;  // used for entries specifying a range of control id's
  UINT nSig;     // signature type (action) or pointer to message #
  AFX_PMSG pfn;  // routine to call (or special value)
};

#include <afxmsg_.h>

#if !(defined(Q_WS_WIN) || defined(Q_WS_WIN32))
typedef DWORD DROPEFFECT;
#endif

class CWnd;
class COleDropTarget : public CCmdTarget
{
   DECLARE_DYNAMIC(COleDropTarget)
public:
   BOOL Register( 
      CWnd* pWnd  
   );
   
   DECLARE_MESSAGE_MAP()
};
  
class COleDropSource : public CCmdTarget
{
   DECLARE_DYNAMIC(COleDropSource)
   
   DECLARE_MESSAGE_MAP()
};

class COleDataSource : public CCmdTarget
{
   DECLARE_DYNAMIC(COleDataSource)
public:
   void CacheGlobalData( 
      CLIPFORMAT cfFormat, 
      HGLOBAL hGlobal, 
      LPFORMATETC lpFormatEtc = NULL  
   );
   DROPEFFECT DoDragDrop( 
      DWORD dwEffects = DROPEFFECT_COPY|DROPEFFECT_MOVE|DROPEFFECT_LINK, 
      LPCRECT lpRectStartDrag = NULL, 
      COleDropSource* pDropSource = NULL  
   );
   
   DECLARE_MESSAGE_MAP()
};

class COleDataObject
{
public:
   BOOL IsDataAvailable( 
      CLIPFORMAT cfFormat, 
      LPFORMATETC lpFormatEtc = NULL  
   );
   HGLOBAL GetGlobalData( 
      CLIPFORMAT cfFormat, 
      LPFORMATETC lpFormatEtc = NULL  
   );
};

DWORD WINAPI WaitForSingleObject(
   HANDLE hHandle,
   DWORD dwMilliseconds
);

BOOL WINAPI CloseHandle(
   HANDLE hObject
);

class CSyncObject : public CObject
{
   DECLARE_DYNAMIC(CSyncObject)
public:
   CSyncObject() : m_hObject(this) {}
   virtual ~CSyncObject() {}
   virtual BOOL Lock(
      DWORD dwTimeout = INFINITE
   ) { return TRUE; }
   virtual BOOL Unlock( )
   { return TRUE; }
   virtual BOOL Unlock(
      LONG lCount,
      LPLONG lpPrevCount = NULL
   ) { return TRUE; }
   HANDLE m_hObject;
protected:
   QMutex _access;
};

class CCriticalSection : public CSyncObject
{
   DECLARE_DYNAMIC(CCriticalSection)
public:
   CCriticalSection();
   virtual ~CCriticalSection();
   BOOL Lock(
      DWORD dwTimeout = INFINITE
   );
   BOOL Unlock( );
protected:
   QMutex* _qtd;
};

class CMutex : public CSyncObject
{
   DECLARE_DYNAMIC(CMutex)
public:
   CMutex(
      BOOL bInitiallyOwn = FALSE,
      LPCTSTR lpszName = NULL,
      LPSECURITY_ATTRIBUTES lpsaAttribute = NULL
   );
   virtual ~CMutex();
   BOOL Lock(
      DWORD dwTimeout = INFINITE
   );
   BOOL Unlock( );
protected:
   QMutex* _qtd;
};

class CSemaphore : public CSyncObject
{
   DECLARE_DYNAMIC(CSemaphore)
};

class CEvent : public CSyncObject
{
   DECLARE_DYNAMIC(CEvent)
public:
   CEvent(
      BOOL bInitiallyOwn = FALSE,
      BOOL bManualReset = FALSE,
      LPCTSTR lpszName = NULL,
      LPSECURITY_ATTRIBUTES lpsaAttribute = NULL
   );
   virtual ~CEvent();
   BOOL SetEvent();
   BOOL ResetEvent();
   BOOL PulseEvent();
   bool m_bSignalled;
   bool m_bManualReset;
   // Qt stuff
   void addWaiter(QSemaphore* waiter);
   QList<QSemaphore*> _waiters;
};

class CString;
BOOL operator==(const CString& s1, const LPCTSTR s2);
BOOL operator!=(const CString& s1, const LPCTSTR s2);
BOOL operator <( const CString& s1, const CString& s2 );

class CString
{
public:
   CString();
   CString(const CString& ref);
   CString(QString str);
   CString(LPCTSTR str);
   virtual ~CString();

   BOOL LoadString( UINT nID );

   void UpdateScratch();

   CString& Append(LPCSTR str);
   CString& Append(LPWSTR str);
   void AppendChar(TCHAR c);
   void AppendFormat(LPCTSTR fmt, ...);
   void AppendFormatV(LPCTSTR fmt, va_list ap);
   void Format( UINT nFormatID, ... );
   void Format(LPCTSTR fmt, ...);
   void FormatV(LPCTSTR fmt, va_list ap);
   void Truncate(int length);
   int FindOneOf( LPCTSTR lpszCharSet ) const;
   CString Tokenize(
      LPCTSTR pszTokens,
      int& iStart
   ) const;
   int ReverseFind( TCHAR ch ) const;
   int Compare( LPCTSTR lpsz ) const;
   BOOL IsEmpty() const;

   const CString& operator=(const CString& str);
   const CString& operator=(LPCTSTR str);
   const CString& operator=(TCHAR c);
   const CString& operator=(QString str);
   CString& operator+(const CString& str);
   CString& operator+(LPCTSTR str);
   CString& operator+(TCHAR c);
   CString& operator+(QString str);
   CString& operator+=(const CString& str);
   CString& operator+=(LPCTSTR str);
   CString& operator+=(TCHAR c);
   CString& operator+=(QString str);
   operator QString() const;
   operator const TCHAR*() const;

   void Empty();
   LPCTSTR GetString() const;
   LPTSTR GetBuffer( int nMinBufLength = 0 );
   void ReleaseBuffer( int nNewLength = -1 );
   int Find( TCHAR ch ) const;
   int Find( LPCTSTR lpszSub ) const;
   int Find( TCHAR ch, int nStart ) const;
   int Find( LPCTSTR pstr, int nStart ) const;
   CString Left( int nCount ) const;
   CString Right( int nCount ) const;
   CString Mid( int nFirst ) const;
   CString Mid( int nFirst, int nCount ) const;
   CString MakeUpper( );
   CString MakeLower( );
   int GetLength() const;
   int CompareNoCase( LPCTSTR lpsz ) const;
   TCHAR GetAt( int nIndex ) const;
   void SetAt( int nIndex, TCHAR ch );

protected:
   QString _qstr;
   QByteArray _qstrn;
};

class CStringA : public CString
{
public:
   CStringA(CString str);
   operator char*() const;
};

class CStringArray
{
public:
   void RemoveAll( );
   INT_PTR Add( LPCTSTR newElement );
   CString GetAt(int idx) const;
   void SetAt(int idx, CString str);
   INT_PTR GetCount( ) const;
   CString operator []( INT_PTR nIndex );
   CString operator []( INT_PTR nIndex ) const;
   BOOL IsEmpty( ) const;
private:
   QList<CString> _qlist;
};

class CException
{
public:
   virtual BOOL GetErrorMessage(
      LPTSTR lpszError,
      UINT nMaxError,
      PUINT pnHelpContext = NULL
   ) const
   {
      lpszError[0] = 0;
      return false;
   }
};

class CFileException : public CException
{
};

class CFile : public CCmdTarget
{
   DECLARE_DYNAMIC(CFile)
public:
   enum
   {
      modeCreate = 0x01,
      modeRead = 0x02,
      modeWrite = 0x04,
      shareDenyWrite = 0x08,
      typeText = 0x10
   };
   static HANDLE hFileNull;
   enum
   {
      begin = 1,
      current = 2,
      end = 3
   };
   CFile();
   CFile(
      LPCTSTR lpszFileName,
      UINT nOpenFlags
   );
   virtual ~CFile();

   virtual BOOL Open(
      LPCTSTR lpszFileName,
      UINT nOpenFlags,
      CFileException* pError = NULL
   );
   virtual ULONGLONG GetLength( ) const;
   virtual void Write(
      const void* lpBuf,
      UINT nCount
   );
   virtual ULONGLONG GetPosition( ) const;
   virtual UINT Read(
      void* lpBuf,
      UINT nCount
   );
   virtual ULONGLONG Seek(
      LONGLONG lOff,
      UINT nFrom
   );
   static void PASCAL Remove(
      LPCTSTR lpszFileName
   );
   virtual void Close();

public:
   HANDLE m_hFile;
protected:
   QFile _qfile;
   
   DECLARE_MESSAGE_MAP()
};

class CStdioFile : public CFile
{
   DECLARE_DYNAMIC(CStdioFile)
public:
   virtual void WriteString( 
      LPCTSTR lpsz  
   );
   virtual LPTSTR ReadString( 
      LPTSTR lpsz, 
      UINT nMax  
   ); 
   virtual BOOL ReadString( 
      CString& rString 
   );
   
   DECLARE_MESSAGE_MAP()
};

class CPoint : public tagPOINT
{
public:
   CPoint()
   {
      x = 0;
      y = 0;
   }
   CPoint(QPoint point)
   {
      x = point.x();
      y = point.y();
   }
   CPoint(int _x, int _y)
   {
      x = _x;
      y = _y;
   }
   CPoint(LPARAM dwPoint)
   {
      x = LOWORD(dwPoint);
      y = HIWORD(dwPoint);
   }
   void SetPoint(int _x, int _y)
   {
      x = _x;
      y = _y;
   }
   bool operator==(CPoint p)
   {
      return ((p.x == x) && (p.y == y));
   }
};

class CSize : public tagSIZE
{
public:
   CSize( ) { cx = 0; cy = 0; }
   CSize(
      int initCX,
      int initCY
   ) { cx = initCX; cy = initCY; }
   CSize(
      SIZE initSize
   ) { cx = initSize.cx; cy = initSize.cy; }
   CSize(
      POINT initPt
   ) { cx = initPt.x; cy = initPt.y; }
   CSize(
      DWORD dwSize
   ) { cx = dwSize&0xFFFF; cy = (dwSize>>16); }
   CSize(QSize qSize) { cx = qSize.width(); cy = qSize.height(); }
};

class CRect : public tagRECT
{
public:
   CRect( );
   CRect(
      int l,
      int t,
      int r,
      int b
   );
   CRect(
      const RECT& srcRect
   );
   CRect(
      LPCRECT lpSrcRect
   );
   CRect(
      POINT point,
      SIZE size
   );
   CRect(
      POINT topLeft,
      POINT bottomRight
   );
   int Width() const { return (right-left)+1; }
   int Height() const { return (bottom-top)+1; }
   CSize Size() const { return CSize((right-left)+1,(bottom-top)+1); }
   void MoveToX(
      int x
   );
   void MoveToY(
      int y
   );
   void MoveToXY(
      int x,
      int y
   );
   void MoveToXY(
      POINT point
   );
   void DeflateRect(
      int x,
      int y
   );
   void DeflateRect(
      SIZE size
   );
   void DeflateRect(
      LPCRECT lpRect
   );
   void DeflateRect(
      int l,
      int t,
      int r,
      int b
   );
   void InflateRect(
      int x,
      int y
   );
   void InflateRect(
      SIZE size
   );
   void InflateRect(
      LPCRECT lpRect
   );
   void InflateRect(
      int l,
      int t,
      int r,
      int b
   );
   operator LPRECT() const
   {
      return (RECT*)this;
   }
   operator LPCRECT() const
   {
      return (const RECT*)this;
   }
   operator QRect() const
   {
      return QRect(left,top,(right-left)+1,(bottom-top)+1);
   }
};

#define AFX_DATA
static AFX_DATA const CRect rectDefault;

#define FWS_ADDTOTITLE 0x1

class CGdiObject : public CObject
{
public:
   CGdiObject() : m_hObject((HGDIOBJ)this) {}
   virtual ~CGdiObject() {}
   operator HGDIOBJ() const
   {
      return m_hObject;
   }
   HGDIOBJ m_hObject;
};

class CPen : public CGdiObject
{
public:
   CPen( );
   CPen(
      int nPenStyle,
      int nWidth,
      COLORREF crColor
   );
   CPen(
      int nPenStyle,
      int nWidth,
      const LOGBRUSH* pLogBrush,
      int nStyleCount = 0,
      const DWORD* lpStyle = NULL
   );
   virtual ~CPen() {}
   BOOL CreatePen(
      int nPenStyle,
      int nWidth,
      COLORREF crColor
   );
   operator QPen() const
   {
      return _qpen;
   }
   operator HPEN() const
   {
      return (HPEN)this;
   }

private:
   QPen _qpen;
};

class CDC;
class CBitmap : public CGdiObject
{
   // Qt interfaces
public:
   CBitmap(QString resource);
   QPixmap* toQPixmap() { return _qpixmap; }

   // MFC interfaces
public:
   CBitmap();
   virtual ~CBitmap();
   BOOL LoadBitmap(
      UINT nIDResource
   );
   BOOL CreateBitmap(
      int nWidth,
      int nHeight,
      UINT nPlanes,
      UINT nBitcount,
      const void* lpBits
   );
   BOOL CreateCompatibleBitmap(
      CDC* pDC,
      int nWidth,
      int nHeight
   );
   CSize SetBitmapDimension(
      int nWidth,
      int nHeight
   );
   CSize GetBitmapDimension( ) const;
   operator QPixmap() const
   {
      return *_qpixmap;
   }
   operator HBITMAP() const
   {
      return (HBITMAP)this;
   }
private:
   QPixmap* _qpixmap;
   bool     _owned;
};

class CBrush : public CGdiObject
{
public:
   CBrush( );
   CBrush(
      COLORREF crColor
   );
   CBrush(
      int nIndex,
      COLORREF crColor
   );
   explicit CBrush(
      CBitmap* pBitmap
   );
   virtual ~CBrush() {}
   BOOL CreateSolidBrush(
      COLORREF crColor
   );
   operator QBrush() const
   {
      return _qbrush;
   }
   operator HBRUSH() const
   {
      return (HBRUSH)this;
   }
private:
   QBrush _qbrush;
};

class CFont : public CGdiObject
{
public:
   CFont() {}
   virtual ~CFont() {}
   BOOL CreateFont(
      int nHeight,
      int nWidth,
      int nEscapement,
      int nOrientation,
      int nWeight,
      BYTE bItalic,
      BYTE bUnderline,
      BYTE cStrikeOut,
      BYTE nCharSet,
      BYTE nOutPrecision,
      BYTE nClipPrecision,
      BYTE nQuality,
      BYTE nPitchAndFamily,
      LPCTSTR lpszFacename
   );
   BOOL CreateFontIndirect(
      const LOGFONT* lpLogFont
   );
   operator QFont() const
   {
      return _qfont;
   }
   operator HFONT() const
   {
      return (HFONT)this;
   }
private:
   QFont _qfont;
};

class CRgn : public CGdiObject
{
public:
   CRgn() {}
   virtual ~CRgn() {}
   operator QRegion() const
   {
      return _qregion;
   }
   operator HRGN() const
   {
      return (HRGN)this;
   }
private:
   QRegion _qregion;
};

class CWnd;

class CDC : public CObject
{
public:
   CDC();
   CDC(CWnd* parent);
   virtual ~CDC();

   static CDC* PASCAL FromHandle( 
      HDC hDC  
   );
   
   void attach();
   void attach(QWidget* parent);
   void detach();
   void flush();
   void doFlush(bool doIt) { _doFlush = doIt; }
   QPainter* painter() { return &_qpainter; }
   QPixmap* pixmap() { return &_qpixmap; }
   QSize pixmapSize() { return _bitmapSize; }
   QWidget* widget() { return _qwidget; }
   QPixmap* bitmap() { return _bitmap?_bitmap->toQPixmap():NULL; }

   BOOL CreateCompatibleDC(
      CDC* pDC
   );
   BOOL DeleteDC( );
   BOOL DrawEdge(
      LPRECT lpRect,
      UINT nEdge,
      UINT nFlags
   );
   BOOL BitBlt(
      int x,
      int y,
      int nWidth,
      int nHeight,
      CDC* pSrcDC,
      int xSrc,
      int ySrc,
      DWORD dwRop
   );
   COLORREF GetPixel(
      int x,
      int y
   ) const;
   COLORREF GetPixel(
      POINT point
   ) const;
   BOOL Rectangle(
      int x1,
      int y1,
      int x2,
      int y2
   );
   BOOL Rectangle(
      LPCRECT lpRect
   );
   void Draw3dRect( LPCRECT lpRect, COLORREF clrTopLeft, COLORREF clrBottomRight )
   {
      Draw3dRect(lpRect->left,lpRect->top,lpRect->right-lpRect->left,lpRect->bottom-lpRect->top,clrTopLeft,clrBottomRight);
   }
   void Draw3dRect( int x, int y, int cx, int cy, COLORREF clrTopLeft, COLORREF clrBottomRight );
   virtual int DrawText(
      LPCTSTR lpszString,
      int nCount,
      LPRECT lpRect,
      UINT nFormat
   );
   int DrawText(
      const CString& str,
      LPRECT lpRect,
      UINT nFormat
   );
   void FillSolidRect(
      LPCRECT lpRect,
      COLORREF clr
   );
   void FillSolidRect(
      int x,
      int y,
      int cx,
      int cy,
      COLORREF clr
   );
   int GetDeviceCaps(
      int nIndex
   ) const;
   BOOL GradientFill(
      TRIVERTEX* pVertices,
      ULONG nVertices,
      void* pMesh,
      ULONG nMeshElements,
      DWORD dwMode
   );
   BOOL LineTo(
      int x,
      int y
   );
   BOOL LineTo(
      POINT point
   )
   {
      return LineTo(point.x,point.y);
   }

   CPoint MoveTo(
      int x,
      int y
   )
   {
      CPoint old = _lineOrg;
      _lineOrg.x = x;
      _lineOrg.y = y;
      return old;
   }
   CPoint MoveTo(
      POINT point
   )
   {
      return MoveTo(point.x,point.y);
   }

   CPoint OffsetWindowOrg(
      int nWidth,
      int nHeight
   )
   {
      CPoint old = _windowOrg;
      _windowOrg.x += nWidth;
      _windowOrg.y += nHeight;
      return old;
   }
   BOOL Polygon(
      LPPOINT lpPoints,
      int nCount
   );

   HGDIOBJ SelectObject(
      HGDIOBJ obj
   );
   CPen* SelectObject(
      CPen* pPen
   );
   CBrush* SelectObject(
      CBrush* pBrush
   );
   virtual CFont* SelectObject(
      CFont* pFont
   );
   CBitmap* SelectObject(
      CBitmap* pBitmap
   );
   int SelectObject(
      CRgn* pRgn
   );
   CGdiObject* SelectObject(
      CGdiObject* pObject
   );
   CObject* SelectObject(
      CObject* pObject
   );
   COLORREF SetBkColor(
      COLORREF crColor
   )
   {
      COLORREF old = _bkColor.red()|(_bkColor.green()<<8)|_bkColor.blue()<<16;
      _bkColor = QColor(GetRValue(crColor),GetGValue(crColor),GetBValue(crColor));
      return old;
   }
   int SetBkMode(
      int nBkMode
   )
   {
      int old = _bkMode;
      _bkMode = nBkMode;
      return old;
   }
   COLORREF SetPixel( int x, int y, COLORREF crColor );
   COLORREF SetPixel( POINT point, COLORREF crColor )
   {
      return SetPixel(point.x,point.y,crColor);
   }

   COLORREF SetTextColor(
      COLORREF crColor
   )
   {
      COLORREF old = _textColor.red()|(_textColor.green()<<8)|_textColor.blue()<<16;
      _textColor = QColor(GetRValue(crColor),GetGValue(crColor),GetBValue(crColor));
      return old;
   }
   virtual CPoint SetViewportOrg(
      int x,
      int y
   )
   {
      CPoint old = _viewportOrg;
      _viewportOrg.x = x;
      _viewportOrg.y = y;
      return old;
   }
   CPoint SetViewportOrg(
      POINT point
   )
   {
      return SetViewportOrg(point.x,point.y);
   }
   CPoint SetWindowOrg(
      int x,
      int y
   )
   {
      CPoint old = _windowOrg;
      _windowOrg.x = x;
      _windowOrg.y = y;
      return old;
   }
   CPoint SetWindowOrg(
      POINT point
   )
   {
      return SetWindowOrg(point.x,point.y);
   }

   BOOL TextOut(
      int x,
      int y,
      LPCTSTR lpszString,
      int nCount
   );
   BOOL TextOut(
      int x,
         int y,
         const CString& str
   );

public:
   HDC  m_hDC;

private:
   CDC(CDC& orig);
   bool attached;
   bool _doFlush;
   QWidget*    _qwidget;
   QPixmap    _qpixmap;
   QPainter   _qpainter;
   CPen*       _pen;
   CBrush*     _brush;
   CFont*      _font;
   CFont*      _defaultFont;
   CBitmap*    _bitmap;
   QSize       _bitmapSize;
   CRgn*       _rgn;
   CGdiObject* _gdiobject;
   CObject*    _object;
   CPoint      _lineOrg;
   QColor      _bkColor;
   int         _bkMode;
   QColor      _textColor;
   CPoint      _windowOrg;
   CPoint      _viewportOrg;
};

class CPaintDC : public CDC
{
public:
   CPaintDC(CWnd* parent) : CDC(parent) {}
};

class CDataExchange
{
};

class QtUIElement
{
public:
   virtual void SetDlgItemInt(
      int nID,
      UINT nValue,
      BOOL bSigned = TRUE
   ) {}
   virtual UINT GetDlgItemInt(
      int nID,
      BOOL* lpTrans = NULL,
      BOOL bSigned = TRUE
   ) const { return 0; }
   virtual void SetDlgItemText(
      int nID,
      LPCTSTR lpszString
   ) {}
   virtual int GetDlgItemText(
      int nID,
      CString& rString
   ) const { return 0; }
   virtual int GetDlgItemText(
      int nID,
      LPTSTR lpStr,
      int nMaxCount
   ) const { return 0; }
   virtual void CheckDlgButton(
      int nIDButton,
      UINT nCheck
   ) {}
   virtual UINT IsDlgButtonChecked(
      int nIDButton
   ) const { return 0; }
   virtual void SetWindowText(
      LPCTSTR lpszString
   ) {}
   virtual int GetWindowTextLength( ) const { return 0; }
   virtual void GetWindowText(
      CString& rString
   ) const {}
   virtual int GetWindowText(
      LPTSTR lpszStringBuf,
      int nMaxCount
   ) const { return 0; }
   virtual void subclassWidget(int nID,CWnd* widget) { return; }
};

class CFrameWnd;
class CScrollBar;
class CMenu;

enum 
{
   adjustBorder = 1
};

class MFCMessageEvent : public QEvent
{
public:
   MFCMessageEvent(Type type);
   MSG msg;   
};

class MFCWidget : public QWidget
{
public:
   MFCWidget(QWidget* parent=0);
};

class CWnd : public MFCWidget, public CCmdTarget, public QtUIElement
{
   Q_OBJECT

   DECLARE_DYNAMIC(CWnd)
public:
   CWnd(CWnd* parent=0);
   virtual ~CWnd();
   
   static CWnd* PASCAL FromHandle( 
      HWND hWnd  
   );   
   static CWnd* PASCAL FromHandlePermanent(
      HWND hWnd 
   );
   
   operator HWND() { return m_hWnd; }
   DWORD GetStyle() const { return _dwStyle; }
   void SetOwner(
      CWnd* pOwnerWnd
   );
   CWnd* GetOwner() const { return m_pOwnerWnd; }
   CMenu* GetMenu( ) const { return m_pMenu; }
   CWnd* GetDescendantWindow( 
      int nID, 
      BOOL bOnlyPerm = FALSE  
   ) const;
   BOOL EnableToolTips(
      BOOL bEnable = TRUE
   );
   virtual LRESULT SendMessage(
      UINT message,
      WPARAM wParam = 0,
      LPARAM lParam = 0
   );
   void SendMessageToDescendants(
      UINT message,
      WPARAM wParam = 0,
      LPARAM lParam = 0,
      BOOL bDeep = TRUE,
      BOOL bOnlyPerm = FALSE
   );
   virtual LRESULT WindowProc( 
      UINT message, 
      WPARAM wParam, 
      LPARAM lParam  
   );
   virtual BOOL OnWndMsg( 
      UINT message, 
      WPARAM wParam, 
      LPARAM lParam, 
      LRESULT* pResult  
   );
   virtual BOOL OnCommand( 
      WPARAM wParam, 
      LPARAM lParam  
   );
   virtual BOOL OnNotify(
      WPARAM, 
      LPARAM lParam, 
      LRESULT* pResult
   );   
   BOOL IsWindowVisible( ) const;
   virtual BOOL EnableWindow(
      BOOL bEnable = TRUE
   );
   virtual BOOL PreCreateWindow(
      CREATESTRUCT& cs
   ) { return TRUE; }
   enum
   {
      reposDefault,
      reposQuery,
      reposExtra
   };
   virtual BOOL Create( 
      LPCTSTR lpszClassName, 
      LPCTSTR lpszWindowName, 
      DWORD dwStyle = WS_OVERLAPPEDWINDOW, 
      const RECT& rect = rectDefault, 
      CWnd* pParentWnd = NULL, 
      LPCTSTR lpszMenuName = NULL, 
      DWORD dwExStyle = 0, 
      CCreateContext* pContext = NULL  
   );
   virtual BOOL CreateEx(
      DWORD dwExStyle,
      LPCTSTR lpszClassName,
      LPCTSTR lpszWindowName,
      DWORD dwStyle,
      const RECT& rect,
      CWnd* pParentWnd,
      UINT nID,
      LPVOID lpParam = NULL
   );
   void UpdateDialogControls(
      CCmdTarget* pTarget,
      BOOL bDisableIfNoHndler
   );
   void RepositionBars(
      UINT nIDFirst,
      UINT nIDLast,
      UINT nIDLeftOver,
      UINT nFlag = reposDefault,
      LPRECT lpRectParam = NULL,
      LPCRECT lpRectClient = NULL,
      BOOL bStretch = TRUE
   );
   void DragAcceptFiles(
      BOOL bAccept = TRUE
   );
   virtual BOOL PreTranslateMessage(
      MSG* pMsg
   );
   void MapWindowPoints(
      CWnd* pwndTo,
      LPRECT lpRect
   ) const;
   void MapWindowPoints(
      CWnd* pwndTo,
      LPPOINT lpPoint,
      UINT nCount
   ) const;
   virtual void CalcWindowRect(
      LPRECT lpClientRect,
      UINT nAdjustType = adjustBorder 
   );
   virtual CScrollBar* GetScrollBarCtrl(
      int nBar
   ) const;
   BOOL SetScrollInfo(
      int nBar,
      LPSCROLLINFO lpScrollInfo,
      BOOL bRedraw = TRUE
   );
   void SetScrollRange(
      int nBar,
      int nMinPos,
      int nMaxPos,
      BOOL bRedraw = TRUE
   );
   int SetScrollPos(
      int nBar,
      int nPos,
      BOOL bRedraw = TRUE
   );
   virtual afx_msg int OnCreate(
      LPCREATESTRUCT lpCreateStruct
   );
   void OnDestroy( );
   void OnMouseMove(UINT,CPoint) {}
   void OnNcMouseMove(UINT nHitTest, CPoint point) {}
   void OnNcLButtonUp(
      UINT nHitTest,
      CPoint point
   ) {}
   BOOL OnEraseBkgnd(
      CDC* pDC
   ) { return TRUE; }
   HBRUSH OnCtlColor(
      CDC* pDC,
      CWnd* pWnd,
      UINT nCtlColor
   ) { return (HBRUSH)NULL; }
   afx_msg void OnPaint( ) {}
   BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message) { return FALSE; }   
   DROPEFFECT OnDragEnter(COleDataObject* pDataObject, DWORD dwKeyState, CPoint point) { return DROPEFFECT_NONE; }
   DROPEFFECT OnDragOver(COleDataObject* pDataObject, DWORD dwKeyState, CPoint point) { return DROPEFFECT_NONE; }
   BOOL OnDrop(COleDataObject* pDataObject, DROPEFFECT dropEffect, CPoint point) { return FALSE; }
   void OnDragLeave() {}
   void OnLButtonDblClk(UINT,CPoint) {}
   void OnLButtonDown(UINT,CPoint) {}
   void OnLButtonUp(UINT,CPoint) {}
   void OnMButtonDblClk(UINT,CPoint) {}
   void OnMButtonDown(UINT,CPoint) {}
   void OnMButtonUp(UINT,CPoint) {}
   void OnRButtonDblClk(UINT,CPoint) {}
   void OnRButtonDown(UINT,CPoint) {}
   void OnRButtonUp(UINT,CPoint) {}
   BOOL OnMouseWheel(UINT,UINT,CPoint) { return TRUE; }
   void OnSize(UINT nType, int cx, int cy) {}
   UINT SetTimer(UINT id, UINT interval, void*);
   void KillTimer(UINT id);
   void OnTimer(UINT_PTR timerId) {}
   void OnKeyDown(UINT,UINT,UINT) {}
   void OnSetFocus(CWnd*);
   void OnKillFocus(CWnd*) {}
   void OnVScroll(UINT,UINT,CScrollBar*) {}
   void OnHScroll(UINT,UINT,CScrollBar*) {}
   void Invalidate(BOOL bErase = TRUE) { /*update();*/ }
   void RedrawWindow(LPCRECT rect=0,CRgn* rgn=0,UINT f=0) { update(); }
   CWnd* SetFocus();
   CWnd* GetFocus();
   void SetCapture(CWnd* p=0) { /* DON'T DO THIS grabMouse(); */ }
   void ReleaseCapture() { /* DON'T DO THIS releaseMouse(); */ }
   CFrameWnd* GetParentFrame( ) const { return m_pFrameWnd; }
   void SetFont(
      CFont* pFont,
      BOOL bRedraw = TRUE
   );
   void MoveWindow(
      LPCRECT lpRect,
         BOOL bRepaint = TRUE
   );
   void MoveWindow(int x,int y,int cx, int cy);
   CDC* GetDC();
   void ReleaseDC(CDC* pDC);
   void ShowWindow(int code);
   void UpdateWindow( ) { _qt->update(); }
   virtual BOOL PostMessage(
      UINT message,
      WPARAM wParam = 0,
      LPARAM lParam = 0
   );
   virtual void DoDataExchange(
      CDataExchange* pDX
   ) {}
   int GetWindowTextLength( ) const;
   CWnd* GetParent() const { return m_pParentWnd?(CWnd*)m_pParentWnd:(CWnd*)m_pFrameWnd; }
   void SetParent(CWnd* parent) { m_pParentWnd = parent; m_pOwnerWnd = parent; _qt->setParent(parent->toQWidget()); }
   void GetWindowText(
      CString& rString
   ) const;
   int GetWindowText(
      LPTSTR lpszStringBuf,
      int nMaxCount
   ) const;
   void SetWindowText(
      LPCTSTR lpszString
   );
   void GetWindowRect(
      LPRECT lpRect
   ) const;
   void GetClientRect(
      LPRECT lpRect
   ) const;
   int GetDlgCtrlID( ) const { return _id; }
   CWnd* GetDlgItem(
      int nID
   ) const;
   void SetDlgItemInt(
      int nID,
      UINT nValue,
      BOOL bSigned = TRUE
   );
   UINT GetDlgItemInt(
      int nID,
      BOOL* lpTrans = NULL,
      BOOL bSigned = TRUE
   ) const;
   void SetDlgItemText(
      int nID,
      LPCTSTR lpszString
   );
   int GetDlgItemText(
      int nID,
      CString& rString
   ) const;
   int GetDlgItemText(
      int nID,
      LPTSTR lpStr,
      int nMaxCount
   ) const;
   void CheckDlgButton(
      int nIDButton,
      UINT nCheck
   );
   UINT IsDlgButtonChecked(
      int nIDButton
   ) const;
   BOOL SubclassDlgItem(
      UINT nID,
      CWnd* pParent
   );
   virtual BOOL DestroyWindow( );
   virtual void PostNcDestroy( ) {}

   // This method only for Qt glue
   UINT_PTR mfcTimerId(int qtTimerId) { return qtToMfcTimer.value(qtTimerId); }
   void setMfcBuddy(CWnd* buddy) { _mfcBuddy = buddy; }
   CWnd* mfcBuddy() const { return _mfcBuddy; } 

   // MFC-to-Qt conversions
protected:
   QHash<UINT_PTR,int> mfcToQtTimer;
   QHash<int,UINT_PTR> qtToMfcTimer;
   QHash<int,CWnd*> mfcToQtWidget;
   CWnd* _mfcBuddy;
   static CFrameWnd* m_pFrameWnd;
   CWnd* m_pParentWnd;
   CWnd* m_pOwnerWnd;
   static CWnd* focusWnd;
   CScrollBar* mfcVerticalScrollBar;
   CScrollBar* mfcHorizontalScrollBar;
   CMenu* m_pMenu;
   CDC* _myDC;
   UINT _id;
   DWORD _dwStyle;

   // Qt interfaces
public:
   QHash<int,CWnd*>* mfcToQtWidgetMap() { return &mfcToQtWidget; }
   virtual void subclassWidget(int nID,CWnd* widget);
   void setParent(QWidget *parent) { _qt->setParent(parent); }
   void setParent(QWidget *parent, Qt::WindowFlags f) { _qt->setParent(parent,f); }
   void setGeometry(const QRect & rect) { _qt->setGeometry(rect); }
   void setGeometry(int x, int y, int w, int h) { _qt->setGeometry(x,y,w,h); }
   const QRect &	geometry () const { return _qt->geometry(); }
   void setContentsMargins(int left, int top, int right, int bottom) { _qt->setContentsMargins(left,top,right,bottom); }
   void setContentsMargins(const QMargins &margins) { _qt->setContentsMargins(margins); }
   void setFocusPolicy(Qt::FocusPolicy policy) { _qt->setFocusPolicy(policy); }
   void setFocusProxy(QWidget *widget) { _qt->setFocusProxy(widget); }
   void setFixedSize(int w, int h) { _qt->setFixedSize(w,h); }
   virtual void setVisible(bool visible) { _qt->setVisible(visible); }
   virtual void setEnabled(bool enabled) { _qt->setEnabled(enabled); }
   QRect rect() const { return _qt->rect(); }
   virtual QWidget* toQWidget() { return _qt; }
public slots:
   void update() { _qt->update(); }
   void repaint() { _qt->update(); }
   void setFocus() { _qt->setFocus(); }
   void setFocus(Qt::FocusReason reason) { _qt->setFocus(reason); }
protected:
   virtual bool event(QEvent *event);   
   virtual bool eventFilter(QObject *object, QEvent *event);
   virtual void leaveEvent(QEvent *event);
   virtual void timerEvent(QTimerEvent *event);
   virtual void mousePressEvent(QMouseEvent *event);
   virtual void mouseMoveEvent(QMouseEvent *event);
   virtual void mouseReleaseEvent(QMouseEvent *event);
   virtual void mouseDoubleClickEvent(QMouseEvent *event);
   virtual void keyPressEvent(QKeyEvent *event);
   virtual void keyReleaseEvent(QKeyEvent *event);
   virtual void resizeEvent(QResizeEvent *event);
   virtual void moveEvent(QMoveEvent *event);
   virtual void paintEvent(QPaintEvent *event);
   virtual void contextMenuEvent(QContextMenuEvent *event);
   void focusInEvent(QFocusEvent *event);
   void focusOutEvent(QFocusEvent *event);
   void closeEvent(QCloseEvent *);
   QWidget* _qt;
   QFrame* _qtd;
   QGridLayout* _grid;
public:
   HWND m_hWnd;
   
   DECLARE_MESSAGE_MAP()
};

typedef void (AFX_MSG_CALL CWnd::*AFX_PMSGW)(void);
	// like 'AFX_PMSG' but for CWnd derived classes only

class CView;
class CDocument;
class CCmdUI;
class CFrameWnd : public CWnd
{
   Q_OBJECT
public:
   DECLARE_DYNCREATE(CFrameWnd)
   // Qt interfaces
public:
   void addControlBar(int area,QWidget* bar);
public slots:
   virtual void menuAction_triggered(int id);

   // MFC interfaces
public:
   CFrameWnd(CWnd* parent = 0);
   virtual ~CFrameWnd();
   virtual BOOL Create( 
      LPCTSTR lpszClassName, 
      LPCTSTR lpszWindowName, 
      DWORD dwStyle = WS_OVERLAPPEDWINDOW, 
      const RECT& rect = rectDefault, 
      CWnd* pParentWnd = NULL, 
      LPCTSTR lpszMenuName = NULL, 
      DWORD dwExStyle = 0, 
      CCreateContext* pContext = NULL  
   );
   BOOL LoadFrame(UINT nIDResource, DWORD dwDefaultStyle,
      CWnd* pParentWnd, CCreateContext* pContext);
   virtual void GetMessageString(
      UINT nID,
      CString& rMessage
   ) const;
   void UpdateFrameTitleForDocument(LPCTSTR title);
   void InitialUpdateFrame(
      CDocument* pDoc,
      BOOL bMakeVisible
   );
   virtual BOOL OnCmdMsg(
      UINT nID,
      int nCode,
      void* pExtra,
      AFX_CMDHANDLERINFO* pHandlerInfo
   );
   void OnSize(UINT nType, int cx, int cy);
   void OnSetFocus(CWnd* pOldWnd);
   virtual void SetMessageText(LPCTSTR fmt,...);
   void SetMessageText(
      UINT nID
   );
   void SetActiveView(CView* pViewNew, BOOL bNotify) { m_pViewActive = pViewNew; }
   CView* GetActiveView( ) const { return m_pViewActive; } // Only one view for SDI
   virtual CDocument* GetActiveDocument( ) { return m_pDocument; }
   virtual void RecalcLayout(
      BOOL bNotify = TRUE
   );
   void OnClose();
   void OnInitMenuPopup(CMenu* pMenu, UINT nIndex, BOOL bSysMenu);

protected:
   CView* m_pViewActive;
   QHBoxLayout* cbrsLeft;
   QHBoxLayout* cbrsRight;
   QVBoxLayout* cbrsTop;
   QVBoxLayout* cbrsBottom;
   QWidget* realCentralWidget;
   CDocument* m_pDocument;
   BOOL m_bInRecalcLayout;
   CRect m_rectBorder;
   CString m_strTitle;
   BOOL m_bAutoMenuEnable;
   
   DECLARE_MESSAGE_MAP()
};

class CDocTemplate;
class CDocument : public QObject, public CCmdTarget
{
   Q_OBJECT
   DECLARE_DYNCREATE(CDocument)
signals:
   void setModified(bool f);
   void documentSaved();
   void documentClosed();

public:
   CDocument();
   void AssertValid() const {}
   void Dump(CDumpContext& dc) const {}
   virtual BOOL OnNewDocument() { DeleteContents(); return TRUE; }
   virtual BOOL OnSaveDocument(LPCTSTR lpszPathName) { emit documentSaved(); return TRUE; }
   virtual BOOL OnOpenDocument(LPCTSTR lpszPathName) { return TRUE; }
   virtual BOOL SaveModified();
   virtual BOOL CanCloseFrame(
      CFrameWnd* pFrame
   );
   virtual void OnCloseDocument();
   virtual void DeleteContents() {}
   virtual BOOL IsModified( ) { return m_bModified; }
   virtual void SetModifiedFlag(BOOL bModified = 1) { m_bModified = bModified; emit setModified(bModified); }
   virtual void OnFileSave();
   virtual void OnFileSaveAs();
   virtual POSITION GetFirstViewPosition() const;
   virtual CView* GetNextView( 
      POSITION& rPosition  
   ) const;
   CDocTemplate* GetDocTemplate() const { return m_pDocTemplate; }
   const CString& GetPathName( ) const { return m_strPathName; }
   virtual void SetPathName(
      LPCTSTR lpszPathName,
      BOOL bAddToMRU = TRUE
   );
   virtual void SetTitle(CString title );
   BOOL DoFileSave();
   BOOL DoSave(LPCTSTR lpszPathName, BOOL bReplace = TRUE);
   virtual void UpdateAllViews(CView *pSender,LPARAM lHint = 0, CObject *pHint = 0);
   virtual CString GetTitle() const { return m_strTitle; }
   void AddView( 
      CView* pView  
   );

   CDocTemplate* m_pDocTemplate;
   BOOL m_bAutoDelete;
   BOOL m_bEmbedded;
protected:
   QList<CView*> _views;
   CString m_strPathName;
   CString m_strTitle;
   BOOL m_bModified;
   
   DECLARE_MESSAGE_MAP()
};

class CView : public CWnd
{
   DECLARE_DYNAMIC(CView)
   // Qt interfaces
protected:
   MFCWidget* viewWidget;
   virtual bool eventFilter(QObject *object, QEvent *event);
   virtual void resizeEvent(QResizeEvent *event);
   virtual void focusInEvent(QFocusEvent *event);
   virtual void paintEvent(QPaintEvent *event);
   virtual void showEvent(QShowEvent *event);
   virtual void mousePressEvent(QMouseEvent *event);
   virtual void mouseMoveEvent(QMouseEvent *event);
   virtual void mouseReleaseEvent(QMouseEvent *event);
   virtual void mouseDoubleClickEvent(QMouseEvent *event);
   virtual bool event(QEvent *event);
   
public:
   CView();
   virtual ~CView();
   virtual BOOL Create( 
      LPCTSTR lpszClassName, 
      LPCTSTR lpszWindowName, 
      DWORD dwStyle = WS_OVERLAPPEDWINDOW, 
      const RECT& rect = rectDefault, 
      CWnd* pParentWnd = NULL, 
      LPCTSTR lpszMenuName = NULL, 
      DWORD dwExStyle = 0, 
      CCreateContext* pContext = NULL  
   );
   CWnd* SetFocus();
   virtual void OnDraw( 
      CDC* pDC  
   ) = 0;
   virtual BOOL OnCmdMsg(
      UINT nID,
      int nCode,
      void* pExtra,
      AFX_CMDHANDLERINFO* pHandlerInfo
   );
   virtual void OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint) { update(); }
   void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags) {}
   void OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags) {}
   void OnSysKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags) {}
   void OnSysKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags) {}
   void OnSetFocus(CWnd *);
   virtual void OnInitialUpdate() {}
   CDocument* GetDocument() const { return m_pDocument; }

protected:
   CDocument* m_pDocument;
   
   DECLARE_MESSAGE_MAP()
};

class CMenu : public QObject, public CCmdTarget
{
   Q_OBJECT
   DECLARE_DYNAMIC(CMenu)
   // Qt interfaces
public:
   QMenu* toQMenu() { return _qtd; }
   QAction* findMenuItem(UINT id) const;
   UINT findMenuID(QAction* action) const;
   HMENU m_hMenu;
public:
   QHash<UINT_PTR,QAction*>* mfcToQtMenuMap() { return &mfcToQtMenu; }
   QHash<QAction*,UINT_PTR>* qtToMfcMenuMap() { return &qtToMfcMenu; }
protected:
   QMenu* _qtd;
   QHash<int,CMenu*>* _cmenu;
   QHash<UINT_PTR,QAction*> mfcToQtMenu;
   QHash<QAction*,UINT_PTR> qtToMfcMenu;
public slots:
   void menuAction_triggered();
   void menuAboutToShow();
signals:
   void menuAction_triggered(int id);

   // MFC interface
public:
   CMenu();
   virtual ~CMenu();
   
   static CMenu* PASCAL FromHandle( 
      HMENU hMenu  
   );
   
   BOOL CreatePopupMenu();
   BOOL LoadMenu(
      UINT nIDResource
   );
   BOOL RemoveMenu(
      UINT nPosition,
      UINT nFlags
   );
   CMenu* GetSubMenu(
      int nPos
   ) const;
   UINT GetMenuItemCount( ) const;
   UINT GetMenuItemID(
      int nPos
   ) const;
   UINT GetMenuState(
      UINT nID,
      UINT nFlags
   ) const;
   int GetMenuString(
      UINT nIDItem,
      LPTSTR lpString,
      int nMaxCount,
      UINT nFlags
   ) const;
   int GetMenuString(
      UINT nIDItem,
      CString& rString,
      UINT nFlags
   ) const;
   BOOL ModifyMenu(
      UINT nPosition,
      UINT nFlags,
      UINT_PTR nIDNewItem = 0,
      LPCTSTR lpszNewItem = NULL
   );
   BOOL AppendMenu(
      UINT nFlags,
      UINT_PTR nIDNewItem = 0,
      LPCTSTR lpszNewItem = NULL
   );
   BOOL InsertMenu( 
      UINT nPosition, 
      UINT nFlags, 
      UINT_PTR nIDNewItem = 0, 
      LPCTSTR lpszNewItem = NULL  
   ); 
   BOOL SetDefaultItem(
      UINT uItem,
      BOOL fByPos = FALSE
   );
   UINT CheckMenuItem(
      UINT nIDCheckItem,
      UINT nCheck
   );
   UINT EnableMenuItem(
      UINT nIDEnableItem,
      UINT nEnable
   );
   BOOL TrackPopupMenu(
      UINT nFlags,
      int x,
      int y,
      CWnd* pWnd,
      LPCRECT lpRect = 0
   );
   BOOL DestroyMenu( );
   
   DECLARE_MESSAGE_MAP()
};

class CDialog : public CWnd
{
   DECLARE_DYNAMIC(CDialog)
   // Qt interfaces
public:
   QDialog* _qtd;
   bool _inited;
protected:

   // MFC interfaces
public:
   CDialog( );
   CDialog(int dlgID,CWnd* parent);
   virtual ~CDialog();
   void EndDialog(
      int nResult
   );
   virtual void OnOK( ) { _qtd->accept(); }
   virtual void OnCancel( ) { _qtd->reject(); }
   void ShowWindow(int code);
   void SetWindowText(
      LPCTSTR lpszString
   );
   virtual BOOL Create(
      UINT nIDTemplate,
      CWnd* pParentWnd = NULL
         );
   virtual BOOL OnInitDialog() { return TRUE; }
   virtual INT_PTR DoModal();
   void MapDialogRect(
      LPRECT lpRect
   ) const;
   virtual BOOL OnCmdMsg(
      UINT nID,
      int nCode,
      void* pExtra,
      AFX_CMDHANDLERINFO* pHandlerInfo
   );
   
   DECLARE_MESSAGE_MAP()
};

class CCommonDialog : public CDialog
{
   DECLARE_DYNAMIC(CCommonDialog)
   // Qt interfaces
public:
protected:

public:
   explicit CCommonDialog(
      CWnd* pParentWnd
   );
   virtual ~CCommonDialog();
   
   DECLARE_MESSAGE_MAP()
};

class CFileDialog : public CCommonDialog
{
   DECLARE_DYNAMIC(CFileDialog)
   // Qt interfaces
public:
   void setDefaultSuffix(const QString & suffix) { _qtd->setDefaultSuffix(suffix); }
   void selectFile(const QString & filename) { _qtd->selectFile(filename); }
//   void setFilter(const QString& filter) { _qtd->setFilter(filter); }
   QStringList selectedFiles() const { return _qtd->selectedFiles(); }
   void translateFilters(LPCTSTR lpszFilter);
protected:
   QFileDialog* _qtd;

   // MFC interfaces
public:
   explicit CFileDialog(
      BOOL bOpenFileDialog,
      LPCTSTR lpszDefExt = NULL,
      LPCTSTR lpszFileName = NULL,
      DWORD dwFlags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT,
      LPCTSTR lpszFilter = NULL,
      CWnd* pParentWnd = NULL,
      DWORD dwSize = 0
   );
   virtual ~CFileDialog();
   INT_PTR DoModal();
   virtual void OnFileNameChange( ) {};
   CString GetFileExt( ) const;
   CString GetFileName( ) const;
   CString GetPathName( ) const;
   POSITION GetStartPosition( ) const;
   CString GetNextPathName(
      POSITION& pos
   ) const;
   OPENFILENAME m_ofn;
   LPOPENFILENAME m_pOFN;
   
   DECLARE_MESSAGE_MAP()
};

class CColorDialog : public CCommonDialog
{
   DECLARE_DYNAMIC(CColorDialog)
   // Qt interfaces
public:
protected:
   QColorDialog* _qtd;
   COLORREF _color;

   // MFC interfaces
public:
   CColorDialog(
      COLORREF clrInit = 0,
      DWORD dwFlags = 0,
      CWnd* pParentWnd = NULL
   );
   virtual ~CColorDialog();
   INT_PTR DoModal();
   COLORREF GetColor( ) const;
   CHOOSECOLOR m_cc;
   
   DECLARE_MESSAGE_MAP()
};

class CScrollBar : public CWnd
{
   Q_OBJECT
   DECLARE_DYNAMIC(CScrollBar)
   // Qt interfaces
public:
   virtual void subclassWidget(int nID,CWnd* widget);
   int sliderPosition() const { return _qtd->sliderPosition(); }
   void setMinimum(int minimum) { _qtd->setMinimum(minimum); }
   void setMaximum(int maximum) { _qtd->setMaximum(maximum); }
   void setValue(int value) { _qtd->setValue(value); }
   void setPageStep(int pageStep) { _qtd->setPageStep(pageStep); }
protected:
   QScrollBar* _qtd;
signals:
   void actionTriggered(int action);

   // MFC interfaces
public:
   CScrollBar(CWnd* parent = 0);
   virtual ~CScrollBar();
   BOOL SetScrollInfo(
      LPSCROLLINFO lpScrollInfo,
      BOOL bRedraw = TRUE
   );
   virtual BOOL Create(
      DWORD dwStyle,
      const RECT& rect,
      CWnd* pParentWnd,
      UINT nID
   );
   int SetScrollPos(
      int nPos,
      BOOL bRedraw = TRUE
   );
   void SetScrollRange(
      int nMinPos,
      int nMaxPos,
      BOOL bRedraw = TRUE
   );
   void ShowScrollBar(
      BOOL bShow = TRUE
   );
   BOOL EnableScrollBar(
      UINT nArrowFlags = ESB_ENABLE_BOTH
   );
   
   DECLARE_MESSAGE_MAP()
};

typedef struct _NM_UPDOWN {
  NMHDR hdr;
  int   iPos;
  int   iDelta;
} NMUPDOWN, *LPNMUPDOWN;

typedef struct {
  int       iBitmap;
  int       idCommand;
  BYTE      fsState;
  BYTE      fsStyle;
#ifdef _WIN64
  BYTE      bReserved[6];
#else 
#if defined(_WIN32)
  BYTE      bReserved[2];
#endif 
#endif 
  DWORD_PTR dwData;
  INT_PTR   iString;
} TBBUTTON, *PTBBUTTON, *LPTBBUTTON;

typedef struct tagNMTOOLBAR {
  NMHDR    hdr;
  int      iItem;
  TBBUTTON tbButton;
  int      cchText;
  LPTSTR   pszText;
  RECT     rcButton;
} NMTOOLBAR, *LPNMTOOLBAR;

class CEdit : public CWnd
{
   Q_OBJECT
   DECLARE_DYNAMIC(CEdit)
   // Qt interfaces
public:
   virtual void subclassWidget(int nID,CWnd* widget);
protected:
   virtual bool event(QEvent *event);
   QPlainTextEdit* _qtd_ptedit;
   QLineEdit* _qtd_ledit;
public slots:
   void textChanged();
   void textEdited(QString str);

   // MFC interfaces
public:
   CEdit(CWnd* parent = 0);
   virtual ~CEdit();
   virtual BOOL Create(
      DWORD dwStyle,
      const RECT& rect,
      CWnd* pParentWnd,
      UINT nID
   );
   void Clear();
   int GetWindowTextLength( ) const;
   void GetWindowText(
      CString& rString
   ) const;
   int GetWindowText(
      LPTSTR lpszStringBuf,
      int nMaxCount
   ) const;
   void SetWindowText(
      LPCTSTR lpszString
   );
   DWORD GetStyle() const;
   void SetSel(
      DWORD dwSelection,
      BOOL bNoScroll = FALSE
   );
   void SetSel(
      int nStartChar,
      int nEndChar,
      BOOL bNoScroll = FALSE
   );
   void ReplaceSel(
      LPCTSTR lpszNewText,
         BOOL bCanUndo = FALSE
   );
#if UNICODE
   void ReplaceSel(
      LPCSTR lpszNewText,
         BOOL bCanUndo = FALSE
   );
#endif
   BOOL EnableWindow(BOOL bEnable);
   void SetDlgItemInt(
      int nID,
      UINT nValue,
      BOOL bSigned = TRUE
   );
   UINT GetDlgItemInt(
      int nID,
      BOOL* lpTrans = NULL,
      BOOL bSigned = TRUE
   ) const;
   void SetDlgItemText(
      int nID,
      LPCTSTR lpszString
   );
   int GetDlgItemText(
      int nID,
      CString& rString
   ) const;
   int GetDlgItemText(
      int nID,
      LPTSTR lpStr,
      int nMaxCount
   ) const;
   
   DECLARE_MESSAGE_MAP()
};

class CButton : public CWnd
{
   Q_OBJECT
   DECLARE_DYNAMIC(CButton)
   // Qt interfaces
public:
   virtual void subclassWidget(int nID,CWnd* widget);
      
protected:
   QPushButton* _qtd_push;
   QRadioButton* _qtd_radio;
   QCheckBox* _qtd_check;
   QGroupBox* _qtd_groupbox;
public slots:
   void clicked();

   // MFC interfaces
public:
   CButton(CWnd* parent = 0);
   virtual ~CButton();
   virtual BOOL Create(
      LPCTSTR lpszCaption,
      DWORD dwStyle,
      const RECT& rect,
      CWnd* pParentWnd,
      UINT nID
   );
   HBITMAP SetBitmap(
      HBITMAP hBitmap
   );
   void SetDlgItemInt(
      int nID,
      UINT nValue,
      BOOL bSigned = TRUE
   );
   UINT GetDlgItemInt(
      int nID,
      BOOL* lpTrans = NULL,
      BOOL bSigned = TRUE
   ) const;
   void SetDlgItemText(
      int nID,
      LPCTSTR lpszString
   );
   int GetDlgItemText(
      int nID,
      CString& rString
   ) const;
   int GetDlgItemText(
      int nID,
      LPTSTR lpStr,
      int nMaxCount
   ) const;
   void CheckDlgButton(
      int nIDButton,
      UINT nCheck
   );
   UINT IsDlgButtonChecked(
      int nIDButton
   ) const;
   
   DECLARE_MESSAGE_MAP()
};

class CSliderCtrl : public CWnd
{
   Q_OBJECT
   DECLARE_DYNAMIC(CSliderCtrl)
   // Qt interfaces
public:
   virtual void subclassWidget(int nID,CWnd* widget);
protected:
   QSlider* _qtd;
public slots:
   void valueChanged(int value);

   // MFC interfaces
public:
   CSliderCtrl(CWnd* parent = 0);
   virtual ~CSliderCtrl();
   virtual BOOL Create(
      DWORD dwStyle,
      const RECT& rect,
      CWnd* pParentWnd,
      UINT nID
   );
   void SetRange(
      short nLower,
      short nUpper
   );
   void SetRangeMax(
      int nMax,
      BOOL bRedraw = FALSE
   );
   void SetPos(
      int nPos
   );
   int GetPos( ) const;
   void SetTicFreq(
      int nFreq
   );
   void SetDlgItemInt(
      int nID,
      UINT nValue,
      BOOL bSigned = TRUE
   );
   UINT GetDlgItemInt(
      int nID,
      BOOL* lpTrans = NULL,
      BOOL bSigned = TRUE
   ) const;
   void SetDlgItemText(
      int nID,
      LPCTSTR lpszString
   );
   int GetDlgItemText(
      int nID,
      CString& rString
   ) const;
   int GetDlgItemText(
      int nID,
      LPTSTR lpStr,
      int nMaxCount
   ) const;
   
   DECLARE_MESSAGE_MAP()
};

class CProgressCtrl : public CWnd
{
   Q_OBJECT
   DECLARE_DYNAMIC(CProgressCtrl)
   // Qt interfaces
public:
   virtual void subclassWidget(int nID,CWnd* widget);
   void setOrientation(Qt::Orientation orient) { _qtd->setOrientation(orient); }
   void setInvertedAppearance(bool inverted) { _qtd->setInvertedAppearance(inverted); }
protected:
   QProgressBar* _qtd;

   // MFC interfaces
public:
   CProgressCtrl(CWnd* parent = 0);
   virtual ~CProgressCtrl();
   virtual BOOL Create( 
      DWORD dwStyle, 
      const RECT& rect, 
      CWnd* pParentWnd, 
      UINT nID  
   );
   void SetRange(
      short nLower,
      short nUpper
   );
   void SetPos(
      int nPos
   );
   int GetPos( ) const;
   
   DECLARE_MESSAGE_MAP()
};

class QSpinBox_MFC : public QSpinBox
{
public:
   QSpinBox_MFC(QWidget* parent=0) : QSpinBox(parent) {}
   void setLineEdit(QLineEdit *edit) { QSpinBox::setLineEdit(edit); }
   QLineEdit* lineEdit() const { return QSpinBox::lineEdit(); }
};

class CSpinButtonCtrl : public CWnd
{
   Q_OBJECT
   DECLARE_DYNAMIC(CSpinButtonCtrl)
   // Qt interfaces
public:
   virtual void subclassWidget(int nID,CWnd* widget);
   virtual bool eventFilter(QObject *object, QEvent *event);
protected:
   QSpinBox_MFC* _qtd;
   int _oldValue;
public slots:
   void control_edited(int value);
   void control_edited(QString value);
   void control_returnPressed();

   // MFC interfaces
public:
   CSpinButtonCtrl(CWnd* parent = 0);
   virtual ~CSpinButtonCtrl();
   virtual BOOL Create(
      DWORD dwStyle,
      const RECT& rect,
      CWnd* pParentWnd,
      UINT nID
   );
   int SetPos(
      int nPos
   );
   int GetPos( ) const;
   void SetRange(
      short nLower,
      short nUpper
   );
   void SetWindowText(
      LPCTSTR lpszString
   );
   void SetDlgItemInt(
      int nID,
      UINT nValue,
      BOOL bSigned = TRUE
   );
   UINT GetDlgItemInt(
      int nID,
      BOOL* lpTrans = NULL,
      BOOL bSigned = TRUE
   ) const;
   void SetDlgItemText(
      int nID,
      LPCTSTR lpszString
   );
   int GetDlgItemText(
      int nID,
      CString& rString
   ) const;
   int GetDlgItemText(
      int nID,
      LPTSTR lpStr,
      int nMaxCount
   ) const;
   
   DECLARE_MESSAGE_MAP()
};

class CComboBox : public CWnd
{
   Q_OBJECT
   DECLARE_DYNAMIC(CComboBox)
   // Qt interfaces
public:
   virtual void subclassWidget(int nID,CWnd* widget);
protected:
   QComboBox* _qtd;
public slots:
   void currentIndexChanged(int index);

   // MFC interfaces
public:
   CComboBox(CWnd* parent = 0);
   virtual ~CComboBox();
   virtual BOOL Create(
      DWORD dwStyle,
      const RECT& rect,
      CWnd* pParentWnd,
      UINT nID
   );
   void SetWindowText(
      LPCTSTR lpszString
   );
   void ResetContent();
   int AddString(
      LPCTSTR lpszString
   );
   void SetCurSel(int sel);
   int GetCurSel( ) const;
   int GetLBText(
      int nIndex,
      LPTSTR lpszText
   ) const;
#if UNICODE
   int GetLBText(
      int nIndex,
      char* lpszText
   ) const;
#endif
   void GetLBText(
      int nIndex,
      CString& rString
   ) const;
   int SelectString(
      int nStartAfter,
      LPCTSTR lpszString
   );
   void SetDlgItemInt(
      int nID,
      UINT nValue,
      BOOL bSigned = TRUE
   );
   UINT GetDlgItemInt(
      int nID,
      BOOL* lpTrans = NULL,
      BOOL bSigned = TRUE
   ) const;
   void SetDlgItemText(
      int nID,
      LPCTSTR lpszString
   );
   int GetDlgItemText(
      int nID,
      CString& rString
   ) const;
   int GetDlgItemText(
      int nID,
      LPTSTR lpStr,
      int nMaxCount
   ) const;
   
   DECLARE_MESSAGE_MAP()
};

class CStatic : public CWnd
{
   DECLARE_DYNAMIC(CStatic)
   // Qt interfaces
public:
   virtual void subclassWidget(int nID,CWnd* widget);
   void setText(const QString & text) { _qtd->setText(text); }
protected:
   QLabel* _qtd;

   // MFC interfaces
public:
   CStatic(CWnd* parent = 0);
   virtual ~CStatic();
   virtual BOOL Create(
      LPCTSTR lpszText,
      DWORD dwStyle,
      const RECT& rect,
      CWnd* pParentWnd,
      UINT nID = 0xffff
   );
   void SetDlgItemInt(
      int nID,
      UINT nValue,
      BOOL bSigned = TRUE
   );
   UINT GetDlgItemInt(
      int nID,
      BOOL* lpTrans = NULL,
      BOOL bSigned = TRUE
   ) const;
   void SetDlgItemText(
      int nID,
      LPCTSTR lpszString
   );
   int GetDlgItemText(
      int nID,
      CString& rString
   ) const;
   int GetDlgItemText(
      int nID,
      LPTSTR lpStr,
      int nMaxCount
   ) const;
   
   DECLARE_MESSAGE_MAP()
};

class CTabCtrl : public CWnd
{
   Q_OBJECT
   DECLARE_DYNAMIC(CTabCtrl)
   // Qt interfaces
public:
   virtual void subclassWidget(int nID,CWnd* widget);
protected:
   QTabWidget* _qtd;
signals:
   void currentChanged(int);

   // MFC interfaces
public:
   CTabCtrl(CWnd* parent = 0);
   virtual ~CTabCtrl();
   virtual BOOL Create( 
     DWORD dwStyle, 
     const RECT& rect, 
     CWnd* pParentWnd, 
     UINT nID  
   );
   LONG InsertItem(
     int nItem,
     LPCTSTR lpszItem
   );
   BOOL DeleteAllItems( );
   int SetCurSel(
     int nItem
   );
   int GetCurSel( ) const;
   
   DECLARE_MESSAGE_MAP()
};

typedef struct tagNMLISTVIEW {
  NMHDR  hdr;
  int    iItem;
  int    iSubItem;
  UINT   uNewState;
  UINT   uOldState;
  UINT   uChanged;
  POINT  ptAction;
  LPARAM lParam;
} NMLISTVIEW, *LPNMLISTVIEW, NM_LISTVIEW;

typedef struct tagNMITEMACTIVATE {
  NMHDR  hdr;
  int    iItem;
  int    iSubItem;
  UINT   uNewState;
  UINT   uOldState;
  UINT   uChanged;
  POINT  ptAction;
  LPARAM lParam;
  UINT   uKeyFlags;
} NMITEMACTIVATE, *LPNMITEMACTIVATE;

typedef struct tagLVFINDINFO {
  UINT flags;
  LPCTSTR psz;
  LPARAM lParam;
  POINT pt;
  UINT vkDirection;
} LVFINDINFO, FAR* LPFINDINFO;

class CImageList;

class CListCtrl : public CWnd
{
   Q_OBJECT
   DECLARE_DYNAMIC(CListCtrl)
   // Qt interfaces
public:
   virtual void subclassWidget(int nID,CWnd* widget);
   QModelIndex currentIndex () const;
protected:
   virtual bool event(QEvent *event);
   virtual bool eventFilter(QObject *object, QEvent *event);
   QTableWidget* _qtd_table;
   QListWidget* _qtd_list;
public slots:
   void itemSelectionChanged();
   void cellClicked(int row, int column);
   void cellDoubleClicked(int row, int column);
   void clicked(QModelIndex index);
   void doubleClicked(QModelIndex index);

   // MFC interfaces
public:
   CListCtrl(CWnd* parent = 0);
   virtual ~CListCtrl();
   virtual BOOL Create(
      DWORD dwStyle,
      const RECT& rect,
      CWnd* pParentWnd,
      UINT nID
   );
   CImageList* SetImageList(
      CImageList* pImageList,
      int nImageListType
   );
   DWORD SetExtendedStyle(
      DWORD dwNewStyle
   );
   int FindItem(
      LVFINDINFO* pFindInfo,
      int nStart = -1
   ) const;
   BOOL SetBkColor(
      COLORREF cr
   );
   BOOL SetTextBkColor(
      COLORREF cr
   );
   BOOL SetTextColor(
      COLORREF cr
   );
   BOOL DeleteAllItems( );
   BOOL DeleteItem(
      int nItem
   );
   int InsertColumn(
      int nCol,
      LPCTSTR lpszColumnHeading,
      int nFormat = LVCFMT_LEFT,
      int nWidth = -1,
      int nSubItem = -1
   );
   UINT GetSelectedCount( ) const;
   int GetSelectionMark( );
   int GetNextItem(
      int nItem,
      int nFlags
   ) const;
   int GetItemText(
      int nItem,
      int nSubItem,
      LPTSTR lpszText,
      int nLen
   ) const;
   CString GetItemText(
      int nItem,
      int nSubItem
   ) const;
#if UNICODE
   int GetItemText(
      int nItem,
      int nSubItem,
      char* lpszText,
      int nLen
   ) const;
#endif
   int InsertItem(
      int nItem,
      LPCTSTR lpszItem,
      int nImage
   );
   int InsertItem(
      int nItem,
      LPCTSTR lpszItem
   );
   int SetSelectionMark(
      int iIndex
   );
   BOOL SetCheck(
      int nItem,
      BOOL fCheck = TRUE
   );
   BOOL GetCheck(
      int nItem
   ) const;
   BOOL SetItemText(
      int nItem,
      int nSubItem,
      LPCTSTR lpszText
   );
   BOOL SetItemText(
      int nItem,
      int nSubItem,
      char* lpszText
   );
   BOOL SetItemState(
      int nItem,
      UINT nState,
      UINT nMask
   );
   int GetItemCount( ) const;
   DWORD_PTR GetItemData(
      int nItem
   ) const;
   BOOL SetItemData(
      int nItem,
         DWORD_PTR dwData
   );
   BOOL EnsureVisible(
      int nItem,
      BOOL bPartialOK
   );
protected:
   CImageList* m_pImageList;
   
   DECLARE_MESSAGE_MAP()
};

class CListBox : public CWnd
{
   Q_OBJECT
   DECLARE_DYNAMIC(CListBox)
   // Qt interfaces
public:
   virtual void subclassWidget(int nID,CWnd* widget);
   void setSelectionMode(QAbstractItemView::SelectionMode mode) { _qtd->setSelectionMode(mode); }
   void setSelectionBehavior(QAbstractItemView::SelectionBehavior behavior) { _qtd->setSelectionBehavior(behavior); }
   QScrollBar* verticalScrollBar() const { return _qtd->verticalScrollBar(); }
   QScrollBar* horizontalScrollBar() const { return _qtd->horizontalScrollBar(); }
   QModelIndex currentIndex () const { return _qtd->currentIndex(); }
protected:
   QListWidget* _qtd;
public slots:
   void itemSelectionChanged();
   void itemClicked(QListWidgetItem* lwi);
   void itemDoubleClicked(QListWidgetItem* lwi);

   // MFC interfaces
public:
   CListBox(CWnd* parent = 0);
   virtual ~CListBox();
   virtual BOOL Create(
      DWORD dwStyle,
      const RECT& rect,
      CWnd* pParentWnd,
      UINT nID
   );
   int GetCount( ) const;
   void ResetContent( );
   int AddString( 
      LPCTSTR lpszItem  
   );
   
   DECLARE_MESSAGE_MAP()
};

class CCheckListBox : public CListBox
{
   DECLARE_DYNAMIC(CCheckListBox)
   // Qt interfaces
public:
   virtual void subclassWidget(int nID,CWnd* widget);
   // MFC interfaces
public:
   CCheckListBox(CWnd* parent = 0);
   virtual ~CCheckListBox();
   int GetCheck(
      int nIndex 
   );
   void SetCheck(
      int nIndex,
      int nCheck 
   );
   void SetCheckStyle( 
      UINT nStyle  
   );
   
   DECLARE_MESSAGE_MAP()
};

typedef QTreeWidgetItem* HTREEITEM;

class CTreeCtrl : public CWnd
{
   Q_OBJECT
   DECLARE_DYNAMIC(CTreeCtrl)
   // Qt interfaces
public:
   virtual void subclassWidget(int nID,CWnd* widget);
   void setSelectionMode(QAbstractItemView::SelectionMode mode) { _qtd->setSelectionMode(mode); }
   void setSelectionBehavior(QAbstractItemView::SelectionBehavior behavior) { _qtd->setSelectionBehavior(behavior); }
   QScrollBar* verticalScrollBar() const { return _qtd->verticalScrollBar(); }
   QScrollBar* horizontalScrollBar() const { return _qtd->horizontalScrollBar(); }
   QModelIndex currentIndex () const { return _qtd->currentIndex(); }
protected:
   QTreeWidget* _qtd;
public slots:
   void itemSelectionChanged();
   void itemClicked(QTreeWidgetItem* item, int column);
   void itemDoubleClicked(QTreeWidgetItem* item, int column);

   // MFC interfaces
public:
   CTreeCtrl(CWnd* parent = 0);
   virtual ~CTreeCtrl();
   virtual BOOL Create(
      DWORD dwStyle,
      const RECT& rect,
      CWnd* pParentWnd,
      UINT nID
   );
   HTREEITEM InsertItem(
      LPCTSTR lpszItem,
      HTREEITEM hParent = TVI_ROOT,
      HTREEITEM hInsertAfter = TVI_LAST
   );
   BOOL SortChildren(
      HTREEITEM hItem
   );
   HTREEITEM GetRootItem( ) const;
   HTREEITEM GetNextItem(
      HTREEITEM hItem,
      UINT nCode
   ) const;
   HTREEITEM GetSelectedItem( ) const;
   BOOL ItemHasChildren(
      HTREEITEM hItem
   ) const;
   DWORD_PTR GetItemData(
      HTREEITEM hItem
   ) const;
   BOOL SetItemData(
      HTREEITEM hItem,
      DWORD_PTR dwData
   );
   CString GetItemText(
      HTREEITEM hItem
   ) const;
   BOOL DeleteItem(
      HTREEITEM hItem
   );
   BOOL Expand(
      HTREEITEM hItem,
      UINT nCode
   );
   HTREEITEM GetParentItem(
      HTREEITEM hItem
   ) const;
   
   DECLARE_MESSAGE_MAP()
};

typedef UINT (*AFX_THREADPROC)(LPVOID lpParameter);

class CWinThread : public QThread, public CCmdTarget
{
   Q_OBJECT
   // Qt interfaces
protected:
   virtual void run();
signals:
   void postThreadMessage(unsigned int m,unsigned int w,unsigned int l);
public slots:
   void recvThreadMessage(unsigned int m,unsigned int w,unsigned int l) { qDebug("CWinThread::recvThreadMessage"); }
public: // For some reason Qt won't recognize the public in the DECLARE_DYNCREATE...
   
   DECLARE_DYNCREATE(CWinThread)
public:
   CWinThread();
   virtual ~CWinThread();
   virtual int Run( );
   BOOL CreateThread(
      DWORD dwCreateFlags = 0,
      UINT nStackSize = 0,
      LPSECURITY_ATTRIBUTES lpSecurityAttrs = NULL
   );
   DWORD ResumeThread( );
   BOOL SetThreadPriority(
      int nPriority
   );
   BOOL PostThreadMessage(
      UINT message ,
      WPARAM wParam,
      LPARAM lParam
         );
   virtual BOOL InitInstance() { return FALSE; }
   virtual BOOL ExitInstance() { return FALSE; }
public:
   HANDLE m_hThread;
   DWORD m_nThreadID;
   CFrameWnd* m_pMainWnd;
   AFX_THREADPROC m_pfnThreadProc;
   LPVOID m_pParam;
   
   DECLARE_MESSAGE_MAP()
};

typedef void (AFX_MSG_CALL CWinThread::*AFX_PMSGT)(void);
	// like 'AFX_PMSG' but for CWinThread-derived classes only

CWinThread* AfxBeginThread( 
   AFX_THREADPROC pfnThreadProc, 
   LPVOID pParam, 
   int nPriority = THREAD_PRIORITY_NORMAL, 
   UINT nStackSize = 0, 
   DWORD dwCreateFlags = 0, 
   LPSECURITY_ATTRIBUTES lpSecurityAttrs = NULL  
); 
CWinThread* AfxBeginThread( 
   CRuntimeClass* pThreadClass, 
   int nPriority = THREAD_PRIORITY_NORMAL, 
   UINT nStackSize = 0, 
   DWORD dwCreateFlags = 0, 
   LPSECURITY_ATTRIBUTES lpSecurityAttrs = NULL  
);

class CDocTemplate : public CCmdTarget
{
   DECLARE_DYNAMIC(CDocTemplate)
public:
   CDocTemplate(UINT nIDResource,CRuntimeClass* pDocClass,CRuntimeClass* pFrameClass,CRuntimeClass* pViewClass);
   virtual CDocument* OpenDocumentFile(
      LPCTSTR lpszPathName,
      BOOL bMakeVisible = TRUE
   ) = 0;
   virtual void InitialUpdateFrame(
      CFrameWnd* pFrame,
      CDocument* pDoc,
      BOOL bMakeVisible = TRUE
   );
   virtual void SetDefaultTitle( 
      CDocument* pDocument  
   ) = 0;
   enum DocStringIndex
   {
      windowTitle,
      docName,
      fileNewName,
      filterName,
      filterExt,
      regFileTypeId,
      regFileTypeName
   };
   virtual BOOL GetDocString(
      CString& rString,
      enum DocStringIndex index
   ) const;
   virtual POSITION GetFirstDocPosition( ) const = 0;
   virtual CDocument* GetNextDoc(
      POSITION& rPos
   ) const = 0;
   CDocument* CreateNewDocument();
   CFrameWnd* CreateNewFrame(CDocument* pDoc, CFrameWnd* pOther);
   virtual void AddDocument(CDocument* pDoc);
   virtual void RemoveDocument(CDocument* pDoc);
protected:
   UINT m_nIDResource;
   CRuntimeClass* m_pDocClass;
   CRuntimeClass* m_pViewClass;
   CRuntimeClass* m_pFrameClass;
   
   DECLARE_MESSAGE_MAP()
};

class CSingleDocTemplate : public CDocTemplate
{
   DECLARE_DYNAMIC(CSingleDocTemplate)
public:
   CSingleDocTemplate(UINT f,CRuntimeClass* pDocClass,CRuntimeClass* pFrameClass,CRuntimeClass* pViewClass);
   virtual CDocument* OpenDocumentFile(
      LPCTSTR lpszPathName,
      BOOL bMakeVisible = TRUE
   );
   virtual CDocument* OpenDocumentFile(
      LPCTSTR lpszPathName,
      BOOL bAddToMRU,
      BOOL bMakeVisible = TRUE
   );
   virtual POSITION GetFirstDocPosition( ) const;
   virtual CDocument* GetNextDoc(
      POSITION& rPos
   ) const;
   virtual void SetDefaultTitle( 
      CDocument* pDocument  
   );
   void AddDocument(CDocument* pDoc);
   void RemoveDocument(CDocument* pDoc);
protected:
   CDocument* m_pOnlyDoc;
   
   DECLARE_MESSAGE_MAP()
};

class CCommandLineInfo : public CObject
{
   DECLARE_DYNAMIC(CCommandLineInfo)
public:
   CCommandLineInfo( );
   virtual void ParseParam(
      const TCHAR* pszParam,
      BOOL bFlag,
      BOOL bLast
   );
   enum
   {
      FileNew,
      FileOpen,
      FilePrint,
      FilePrintTo,
      FileDDE,
      AppRegister,
      AppUnregister,
      RestartByRestartManager,
      FileNothing = -1
   };
   BOOL m_bRunAutomated;
   BOOL m_bRunEmbedded;
   BOOL m_bShowSplash;
   UINT m_nShellCommand;
   CString m_strDriverName;
   CString m_strFileName;
   CString m_strPortName;
   CString m_strPrinterName;
   // Qt interface
   QStringList _args;
};

#define _AFX_MRU_COUNT 4
#define AFX_ABBREV_FILENAME_LEN 30

class CRecentFileList
{
public:
   CRecentFileList( 
      UINT nStart, 
      LPCTSTR lpszSection, 
      LPCTSTR lpszEntryFormat, 
      int nSize, 
      int nMaxDispLen = AFX_ABBREV_FILENAME_LEN  
   );
   int GetSize( ) const;
   virtual void Add( 
      LPCTSTR lpszPathName  
   );
   virtual BOOL GetDisplayName( 
      CString& strName, 
      int nIndex, 
      LPCTSTR lpszCurDir, 
      int nCurDir, 
      BOOL bAtLeastName = TRUE 
   ) const;
protected:
   QString _regSection;
   QString _regEntryFormat;
   int _nSize;
   QStringList _recentFiles;
};

class CWinApp : public CWinThread
{
   DECLARE_DYNCREATE(CWinApp)
   // Qt interfaces
public:
   QMainWindow* qtMainWindow;
   
public:
   CWinApp();
   virtual ~CWinApp();
   BOOL DoPromptFileName(CString& fileName, UINT nIDSTitle, DWORD lFlags,
      BOOL bOpenFileDialog, CDocTemplate* pTemplate);
   void ParseCommandLine(
      CCommandLineInfo& rCmdInfo
   );
   BOOL ProcessShellCommand(
      CCommandLineInfo& rCmdInfo
   );
   void LoadStdProfileSettings( 
      UINT nMaxMRU = _AFX_MRU_COUNT  
   );
   virtual void AddToRecentFileList( 
      LPCTSTR lpszPathName  
   );
   void AddDocTemplate(CDocTemplate* pDocTemplate);
   POSITION GetFirstDocTemplatePosition( ) const;
   CDocTemplate* GetNextDocTemplate(
      POSITION& pos
   ) const;
   virtual CDocument* OpenDocumentFile(
      LPCTSTR lpszFileName
   );
   virtual BOOL PreTranslateMessage(
      MSG* pMsg
   );
   HICON LoadIcon(
      UINT nIDResource
   ) const;
   virtual BOOL InitInstance();
   HCURSOR LoadStandardCursor(
      LPCTSTR lpszCursorName
   ) const;
   virtual CWnd * GetMainWnd( ) { return m_pMainWnd; }
   afx_msg void OnFileNew( );
   afx_msg void OnFileOpen( );
   afx_msg void OnUpdateRecentFileList(CCmdUI *pCmdUI);
   afx_msg void OnOpenRecentFile( UINT nID );
   BOOL ExitInstance() { return TRUE; }
   void OnAppExit();
public:
   CRecentFileList* m_pRecentFileList;
   // Qt interfaces

protected:
   QList<CDocTemplate*> _docTemplates;
   
   DECLARE_MESSAGE_MAP()
};

#define CBRS_TOP      0x0001 // Control bar is at the top of the frame window.
#define CBRS_ALIGN_TOP CBRS_TOP
#define CBRS_BOTTOM   0x0002 //  Control bar is at the bottom of the frame window.
#define CBRS_NOALIGN  0x0000 //   Control bar is not repositioned when the parent is resized.
#define CBRS_LEFT     0x0004 // Control bar is at the left of the frame window.
#define CBRS_RIGHT    0x0008 //  Control bar is at the right of the frame window.
#define CBRS_FLYBY    0x0010
#define CBRS_TOOLTIPS 0x0020
#define CBRS_SIZE_DYNAMIC 0x2000

class CControlBar : public CWnd
{
   DECLARE_DYNAMIC(CControlBar)
public:
   virtual LRESULT WindowProc( 
      UINT nMsg, 
      WPARAM wParam, 
      LPARAM lParam  
   );
   virtual CSize CalcFixedLayout(
      BOOL bStretch,
      BOOL bHorz
   );
   void SetBarStyle(
      DWORD dwStyle
   );
   virtual BOOL IsVisible() const;
   virtual LRESULT OnSizeParent(WPARAM, LPARAM lParam);
public:
   CSize m_sizeDefault;
   
   DECLARE_MESSAGE_MAP()
};

typedef struct {
  UINT     cbSize;
  UINT     fMask;
  UINT     fStyle;
  COLORREF clrFore;
  COLORREF clrBack;
  LPTSTR   lpText;
  UINT     cch;
  int      iImage;
  HWND     hwndChild;
  UINT     cxMinChild;
  UINT     cyMinChild;
  UINT     cx;
  HBITMAP  hbmBack;
  UINT     wID;
#if (_WIN32_IE >= 0x0400)
  UINT     cyChild;
  UINT     cyMaxChild;
  UINT     cyIntegral;
  UINT     cxIdeal;
  LPARAM   lParam;
  UINT     cxHeader;
#endif
#if (_WIN32_WINNT >= 0x0600)
  RECT     rcChevronLocation;
  UINT     uChevronState;
#endif
} REBARBANDINFO, *LPREBARBANDINFO;

class CReBar;

class CReBarCtrl : public CWnd
{
   Q_OBJECT
   DECLARE_DYNAMIC(CReBarCtrl)
   // Qt interfaces
public:
   virtual void subclassWidget(int nID,CWnd* widget);
protected:
   QToolBar* _qtd;
public slots:
   void toolBarAction_triggered();
signals:
   void toolBarAction_triggered(int id);

   // MFC interfaces
public:
   virtual BOOL Create(
      DWORD dwStyle,
      const RECT& rect,
      CWnd* pParentWnd,
      UINT nID
   );
   BOOL InsertBand(
      UINT uIndex,
      REBARBANDINFO* prbbi
   );
   void MinimizeBand(
      UINT uBand
   );
   
   DECLARE_MESSAGE_MAP()
};

class CReBar : public CControlBar
{
   DECLARE_DYNAMIC(CReBar)
public:
   CReBar();
   virtual ~CReBar();
   virtual BOOL Create(
      CWnd* pParentWnd,
      DWORD dwCtrlStyle = RBS_BANDBORDERS,
      DWORD dwStyle = WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS | WS_CLIPCHILDREN | CBRS_TOP,
      UINT nID = AFX_IDW_REBAR
   );
   virtual LRESULT WindowProc( 
      UINT nMsg, 
      WPARAM wParam, 
      LPARAM lParam  
   );
   CReBarCtrl& GetReBarCtrl() const { return *m_pReBarCtrl; }
protected:
   CReBarCtrl* m_pReBarCtrl;
   
   DECLARE_MESSAGE_MAP()
};

#define TBBS_BUTTON     1 //  Standard pushbutton (default)
#define TBBS_SEPARATOR  2 //  Separator
#define TBBS_CHECKBOX   3 //  Auto check-box button
#define TBBS_GROUP      4 //  Marks the start of a group of buttons
#define TBBS_CHECKGROUP 5 //  Marks the start of a group of check-box buttons
#define TBBS_DROPDOWN   6 //  Creates a drop-down list button
#define TBBS_AUTOSIZE   7 //  The button's width will be calculated based on the text of the button, not on the size of the image
#define TBBS_NOPREFIX   8 //  The button text will not have an accelerator prefix associated with it

class CToolBar : public CControlBar
{
   Q_OBJECT
   DECLARE_DYNAMIC(CToolBar)
   // Qt interfaces
public:
   virtual void subclassWidget(int nID,CWnd* widget);
   QList<QObject*>* toolBarActions() { return &_toolBarActions; }
protected:
   QToolBar* _qtd;
   QList<QObject*> _toolBarActions;
public slots:
   void toolBarAction_triggered();
   void menu_aboutToShow();
signals:
   void toolBarAction_triggered(int id);
   void toolBarAction_menu_aboutToShow(int id);

   // MFC interfaces
public:
   CToolBar(CWnd* parent = 0);
   virtual ~CToolBar();
   virtual BOOL Create( 
      CWnd* pParentWnd, 
      DWORD dwStyle = WS_CHILD |   WS_VISIBLE | CBRS_TOP, 
      UINT nID = AFX_IDW_TOOLBAR  
   );
   virtual BOOL CreateEx(
      CWnd* pParentWnd,
      DWORD dwCtrlStyle = TBSTYLE_FLAT,
      DWORD dwStyle = WS_CHILD | WS_VISIBLE | CBRS_ALIGN_TOP,
      CRect rcBorders = CRect(
      0,
      0,
      0,
      0
   ),
      UINT nID = AFX_IDW_TOOLBAR
   );
   BOOL LoadToolBar(
      UINT nIDResource
   );
   void SetButtonStyle(
      int nIndex,
      UINT nStyle
   );
   
   DECLARE_MESSAGE_MAP()
};

class CDialogBar : public CControlBar
{
   Q_OBJECT
   DECLARE_DYNAMIC(CDialogBar)
   // Qt interfaces
protected:
   CDialog*     _mfcd;
public:
   CDialogBar();
   ~CDialogBar();
   virtual BOOL Create(
      CWnd* pParentWnd,
      UINT nIDTemplate,
      UINT nStyle,
      UINT nID
   );
   virtual CSize CalcFixedLayout(
      BOOL bStretch,
      BOOL bHorz
   );
   
   DECLARE_MESSAGE_MAP()
};

class CStatusBar : public CControlBar
{
   DECLARE_DYNAMIC(CStatusBar)
   // Qt interfaces
protected:
   QHash<int,CStatic*> _panes;

   // MFC interfaces
public:
   CStatusBar(CWnd* parent = 0);
   virtual ~CStatusBar();
   virtual BOOL Create(
      CWnd* pParentWnd,
      DWORD dwStyle = WS_CHILD | WS_VISIBLE | CBRS_BOTTOM,
      UINT nID = AFX_IDW_STATUS_BAR
   );
   void SetWindowText(
      LPCTSTR lpszString
   );
   BOOL SetIndicators(
      const UINT* lpIDArray,
      int nIDCount
   );
   BOOL SetPaneText(
      int nIndex,
      LPCTSTR lpszNewText,
      BOOL bUpdate = TRUE
   );
   
   DECLARE_MESSAGE_MAP()
};

#if UNICODE
#define LPSTR_TEXTCALLBACKW  ((LPWSTR)-1)
#define LPSTR_TEXTCALLBACK LPSTR_TEXTCALLBACKW
#else
#define LPSTR_TEXTCALLBACKA  ((LPSTR)-1)
#define LPSTR_TEXTCALLBACK LPSTR_TEXTCALLBACKA
#endif

class CToolTipCtrl : public CWnd
{
   DECLARE_DYNAMIC(CToolTipCtrl)
   // Qt interfaces
public:
   virtual void subclassWidget(int nID, CWnd *widget);
protected:
   QToolTip* _qtd;
   QList<CWnd*> _tippers;
   // MFC interfaces
public:
   CToolTipCtrl( );
   virtual BOOL Create(
      CWnd* pParentWnd,
         DWORD dwStyle = 0
   );
   void Activate(
      BOOL bActivate
   );
   BOOL AddTool(
      CWnd* pWnd,
      UINT nIDText,
      LPCRECT lpRectTool = NULL,
      UINT_PTR nIDTool = 0
   );
   BOOL AddTool(
      CWnd* pWnd,
      LPCTSTR lpszText = LPSTR_TEXTCALLBACK,
      LPCRECT lpRectTool = NULL,
      UINT_PTR nIDTool = 0
   );
   void RelayEvent(
      LPMSG lpMsg
   );
   
   DECLARE_MESSAGE_MAP()
};

class CCmdUI
{
public:
   CCmdUI();
   void ContinueRouting( );
   BOOL DoUpdate(CCmdTarget* pTarget, BOOL bDisableIfNoHndler);
   virtual void Enable(
      BOOL bOn = TRUE
   );
   virtual void SetCheck(
      int nCheck = 1
   );
   virtual void SetRadio(
      BOOL bOn = TRUE
   );
   virtual void SetText(
      LPCTSTR lpszText
   );
   UINT m_nID;
   UINT m_nIndex;
   UINT m_nIndexMax;
   CMenu* m_pMenu;
   CWnd* m_pOther;
   CMenu* m_pSubMenu;
   BOOL m_bContinueRouting;
   BOOL m_bEnableChanged;
};

class CArchive
{
public:
   BOOL IsStoring( ) const;
};

template < class TYPE, class ARG_TYPE = const TYPE& >
class CArray :
   public CObject
{
public:
   INT_PTR GetCount( ) const
   {
      return _qlist.count();
   }

   TYPE& operator[](
      INT_PTR nIndex
   )
   {
      return _qlist[nIndex];
   }
   const TYPE& operator[](
      INT_PTR nIndex
   ) const
   {
      return _qlist.at(nIndex);
   }
   void RemoveAll( )
   {
      _qlist.clear();
   }
   void FreeExtra( )
   {
   }
   INT_PTR Add(
      ARG_TYPE newElement
   )
   {
      _qlist.append(newElement);
      return _qlist.count()-1;
   }
protected:
   QList<TYPE> _qlist;
};

template< class KEY, class ARG_KEY, class VALUE, class ARG_VALUE >
class CMap :
      public CObject
{
public:
   VALUE& operator[](
         ARG_KEY key
   )
   {
      return _qmap[key];
   }

protected:
   QMap<KEY,VALUE> _qmap;
};

class CFileFind
{
public:
   virtual BOOL FindFile(
      LPCTSTR pstrName = NULL,
      DWORD dwUnused = 0
   );
   virtual BOOL FindNextFile( );
   virtual CString GetFileName( ) const;
   virtual CString GetFilePath( ) const;
   virtual CString GetFileTitle( ) const;
   BOOL IsDirectory( ) const;
   BOOL IsHidden( ) const;
   virtual BOOL IsDots( ) const;
protected:
   QDir _qdir;
   QFileInfoList _qfiles;
   int _idx;
};

#define ILC_COLOR 0
#define ILC_COLOR4 4
#define ILC_COLOR8 8
#define ILC_COLOR16 16
#define ILC_COLOR24 24
#define ILC_COLOR32 32
#define ILC_COLORDDB 254

class CImageList : public CObject
{
   DECLARE_DYNAMIC(CImageList)
public:
   CImageList();
   BOOL Create(
      int cx,
      int cy,
      UINT nFlags,
      int nInitial,
      int nGrow
   );
   int Add(
      CBitmap* pbmImage,
      CBitmap* pbmMask
   );
   int Add(
      CBitmap* pbmImage,
      COLORREF crMask
   );
   int Add(
      HICON hIcon
   );
   HICON ExtractIcon(
      int nImage
   );
protected:
   QList<CBitmap*> _images;
};

class CPropertyPage : public CDialog
{
   Q_OBJECT
   DECLARE_DYNAMIC(CPropertyPage)
   // Qt interfaces
signals:
   void setModified();
   
   // MFC interfaces
public:
   explicit CPropertyPage(
      UINT nIDTemplate,
      UINT nIDCaption = 0,
      DWORD dwSize = sizeof(PROPSHEETPAGE)
   );
   virtual ~CPropertyPage();
   void SetModified(
      BOOL bChanged = TRUE
   );
   virtual BOOL OnApply( );
   virtual BOOL OnSetActive( );
   
   DECLARE_MESSAGE_MAP()
};

class CPropertySheet : public CWnd
{
   Q_OBJECT
   DECLARE_DYNAMIC(CPropertySheet)
   // Qt interfaces
public:
   QDialog* _qtd;
   QTabWidget* _qtabwidget;
   QDialogButtonBox* _qbuttons;
   QList<CPropertyPage*> _pages;
   UINT _selectedPage;
public slots:
   void tabWidget_currentChanged(int idx);
   void ok_clicked();
   void cancel_clicked();
   void apply_clicked();
   void pageModified();
public:
   void _commonConstruct(CWnd* parent,UINT selectedPage);
   explicit CPropertySheet(
      UINT nIDCaption,
      CWnd* pParentWnd = NULL,
      UINT iSelectPage = 0
   );
   explicit CPropertySheet(
      LPCTSTR pszCaption,
      CWnd* pParentWnd = NULL,
      UINT iSelectPage = 0
   );
   CPropertySheet(
      UINT nIDCaption,
      CWnd* pParentWnd,
      UINT iSelectPage,
      HBITMAP hbmWatermark,
      HPALETTE hpalWatermark = NULL,
      HBITMAP hbmHeader = NULL
   );
   CPropertySheet(
      LPCTSTR pszCaption,
      CWnd* pParentWnd,
      UINT iSelectPage,
      HBITMAP hbmWatermark,
      HPALETTE hpalWatermark = NULL,
      HBITMAP hbmHeader = NULL
   );
   void AddPage(
      CPropertyPage *pPage
   );
   virtual INT_PTR DoModal( );
   
   DECLARE_MESSAGE_MAP()
};

int StretchDIBits(
  CDC& dc,
  int XDest,
  int YDest,
  int nDestWidth,
  int nDestHeight,
  int XSrc,
  int YSrc,
  int nSrcWidth,
  int nSrcHeight,
  const VOID *lpBits,
  const BITMAPINFO *lpBitsInfo,
  UINT iUsage,
  DWORD dwRop
);

CWinApp* AfxGetApp();
CFrameWnd* AfxGetMainWnd();
CWinThread* AfxGetThread();

#define AFXAPI
#define AFX_STATIC static

#if defined(Q_OS_WIN32)
#define MB_CANCELTRYCONTINUE 6
#endif

#define IDCONTINUE 11

int AfxMessageBox(
   LPCTSTR lpszText,
   UINT nType = MB_OK,
   UINT nIDHelp = 0
);

int AFXAPI AfxMessageBox(
   UINT nIDPrompt,
   UINT nType = MB_OK,
   UINT nIDHelp = (UINT) -1
);

void AfxFormatString1(
   CString& rString,
   UINT nIDS,
   LPCTSTR lpsz1
);

void AfxGetFileTitle(
   LPCTSTR path,
   LPTSTR file,
   UINT max
);

HINSTANCE AFXAPI AfxGetInstanceHandle( );

HGDIOBJ GetStockObject(
   int fnObject
);

int EnumFontFamiliesEx(
   HDC hdc,
   LPLOGFONT lpLogfont,
   FONTENUMPROC lpEnumFontFamExProc,
   LPARAM lParam,
   DWORD dwFlags
);

HMMIO mmioOpen(
  LPTSTR szFilename,
  LPMMIOINFO lpmmioinfo,
  DWORD dwOpenFlags
);

MMRESULT mmioCreateChunk(
  HMMIO hmmio,
  LPMMCKINFO lpck,
  UINT wFlags
);

LONG mmioWrite(
  HMMIO hmmio,
  char _huge *pch,
  LONG cch
);

MMRESULT mmioAscend(
  HMMIO hmmio,
  LPMMCKINFO lpck,
  UINT wFlags
);

MMRESULT mmioDescend(
  HMMIO hmmio, 
  LPMMCKINFO lpck,
  const MMCKINFO* lpckParent,
  UINT wFlags
);

LONG mmioSeek(
  HMMIO hmmio,
  LONG lOffset,
  int iOrigin
);

MMRESULT mmioAdvance(
  HMMIO hmmio,
  LPMMIOINFO lpmmioinfo,
  UINT wFlags
);

MMRESULT mmioGetInfo(
  HMMIO hmmio,
  LPMMIOINFO lpmmioinfo,
  UINT wFlags
);

MMRESULT mmioSetInfo(
  HMMIO hmmio,
  LPMMIOINFO lpmmioinfo,
  UINT wFlags
);

MMRESULT mmioClose(
  HMMIO hmmio,
  UINT wFlags
);

VOID WINAPI Sleep(
  DWORD dwMilliseconds
);

VOID WINAPI ExitProcess(
  UINT uExitCode
);

BOOL WINAPI MoveFileEx(
  LPCTSTR lpExistingFileName,
  LPCTSTR lpNewFileName,
  DWORD dwFlags
);

BOOL WINAPI DeleteFile(
  LPCTSTR lpFileName
);

DWORD WINAPI GetTempPath(
  DWORD nBufferLength,
  LPTSTR lpBuffer
);

UINT WINAPI GetTempFileName(
  LPCTSTR lpPathName,
  LPCTSTR lpPrefixString,
  UINT uUnique,
  LPTSTR lpTempFileName
);

CString qtMfcStringResource(int id);

CBitmap* qtMfcBitmapResource(int id);

QIcon* qtIconResource(int id);

CDocument* openFile(QString fileName);

UINT qtToMfcKeycode(UINT qt);

extern bool ideifiedFamiTracker;
void ideifyFamiTracker();

#endif // CQTMFC_H
