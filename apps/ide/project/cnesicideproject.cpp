#include "cnesicideproject.h"
#include "main.h"

#include "nes_emulator_core.h"
#include "c64_emulator_core.h"
#include "cdockwidgetregistry.h"

#define PROJECT_HEADER_FILE "project_data.h"
#define PROJECT_SOURCE_FILE "project_data.s"

#define NESICIDE_HEADER "; This file is automatically generated by NESICIDE.\n" \
                        "; DO NOT EDIT\n\n"

CNesicideProject::CNesicideProject()
{
   // Add node to tree as root
   InitTreeItem(":/resources/folder_closed.png");

   // Allocate children
   m_pProject = new CProject(this);
   m_pCartridge = new CCartridge(this);

   m_isInitialized = false;
   m_isDirty = false;

   m_projectTitle = "(No project loaded)";
   setProjectOutputBasePath(".");
   setProjectOutputName("");
   m_projectHeaderFileName = PROJECT_HEADER_FILE;
   m_projectSourceFileName = PROJECT_SOURCE_FILE;
   m_projectUsesCHRROM = true;
}

CNesicideProject::~CNesicideProject()
{
   if ( m_pProject )
   {
      delete m_pProject;
   }
   if ( m_pCartridge )
   {
      delete m_pCartridge;
   }
}

int CNesicideProject::findSource ( char* objname, char** objdata, int* size )
{
   IProjectTreeViewItemIterator iter(nesicideProject->getProject()->getSources());
   CSourceItem* source;

   (*objdata) = NULL;
   (*size) = 0;

   while ( iter.current() != NULL )
   {
      if ( iter.current()->caption() == objname )
      {
         source = dynamic_cast<CSourceItem*>(iter.current());
         if ( source )
         {
            (*objdata) = strdup(source->sourceCode().toLatin1().constData());
            (*size) = strlen((*objdata));
         }
         break;
      }

      iter.next();
   }
   return (*size);
}

void CNesicideProject::initializeProject()
{
   QString cc65home = qgetenv("CC65_HOME");
   QDir dir = m_projectOutputBasePath;

   // Initialize this node's attributes
   m_projectPaletteEntries.clear();
   m_sourceSearchPaths.clear();

   // Palette is target-dependent!
   if ( !m_projectTarget.compare("nes",Qt::CaseInsensitive) )
   {
      for (int col=0; col < nesGetNumColors(); col++)
      {
         m_projectPaletteEntries.append(QColor(nesGetPaletteRedComponent(col),
                                               nesGetPaletteGreenComponent(col),
                                               nesGetPaletteBlueComponent(col)));
      }

      // Add default expected source search paths that are target-dependent.
      // Doing it here to prevent users with pre-existing projects from having
      // to add the paths manually.
      addSourceSearchPath(QDir::fromNativeSeparators(cc65home+"/libsrc/nes"));
   }
   else if ( !m_projectTarget.compare("c64",Qt::CaseInsensitive) )
   {
      for (int col=0; col < c64GetNumColors(); col++)
      {
         m_projectPaletteEntries.append(QColor(c64GetPaletteRedComponent(col),
                                               c64GetPaletteGreenComponent(col),
                                               c64GetPaletteBlueComponent(col)));
      }

      // Add default expected source search paths that are target-dependent.
      // Doing it here to prevent users with pre-existing projects from having
      // to add the paths manually.
      addSourceSearchPath(QDir::fromNativeSeparators(cc65home+"/libsrc/c64"));
   }

   // Add default expected source search paths that are target-independent.
   // Doing it here to prevent users with pre-existing projects from having
   // to add the paths manually.
   addSourceSearchPath(QDir::fromNativeSeparators(cc65home+"/libsrc"));

   // Notify the fact that the project data has been initialized properly
   m_projectFileName = "(unset)";
   m_projectTitle = "(No project loaded)";
   setProjectOutputBasePath(".");
   setProjectOutputName("");
   m_projectHeaderFileName = PROJECT_HEADER_FILE;
   m_projectSourceFileName = PROJECT_SOURCE_FILE;
   m_compilerDefinedSymbols = "";
   m_compilerIncludePaths = "";
   m_compilerAdditionalOptions = "";
   m_assemblerDefinedSymbols = "";
   m_assemblerIncludePaths = "";
   m_assemblerAdditionalOptions = "";
   m_linkerConfigFile = "";
   m_makefileCustomRulesFile = "";
   m_linkerAdditionalOptions = "";
   m_linkerAdditionalDependencies = "";

   m_saveStateDoc.clear();

   m_tileProperties.clear();

   m_isInitialized = true;
   m_isDirty = false;

   // Initialize child nodes
   m_pProject->initializeProject();
   m_pCartridge->initializeProject();

   // Add child nodes to tree
   appendChild(m_pProject);
   appendChild(m_pCartridge);
}

void CNesicideProject::terminateProject()
{
   CBreakpointInfo* pBreakpoints;
   CMarker* pMarkers;
   int idx;

   // Clear out existing breakpoints...
   if ( !m_projectTarget.compare("nes",Qt::CaseInsensitive) )
   {
      pBreakpoints = nesGetBreakpointDatabase();
      if ( (pBreakpoints) && (pBreakpoints->GetNumBreakpoints()) )
      {
         for ( idx = pBreakpoints->GetNumBreakpoints()-1; idx >= 0; idx-- )
         {
            pBreakpoints->RemoveBreakpoint(idx);
         }
      }
   }
   else if ( !m_projectTarget.compare("c64",Qt::CaseInsensitive) )
   {
      pBreakpoints = c64GetBreakpointDatabase();
      if ( pBreakpoints->GetNumBreakpoints() )
      {
         for ( idx = pBreakpoints->GetNumBreakpoints()-1; idx >= 0; idx-- )
         {
            pBreakpoints->RemoveBreakpoint(idx);
         }
      }
   }

   // Terminate child nodes
   m_pProject->terminateProject();
   m_pCartridge->terminateProject();

   // Remove child nodes from tree
   removeChild(m_pCartridge);
   removeChild(m_pProject);

   // Notify the fact that the project data is no longer valid
   m_projectFileName = "(unset)";
   m_projectTitle = "(No project loaded)";
   setProjectOutputBasePath(".");
   setProjectOutputName("");
   m_projectHeaderFileName = PROJECT_HEADER_FILE;
   m_projectSourceFileName = PROJECT_SOURCE_FILE;
   m_compilerDefinedSymbols = "";
   m_compilerIncludePaths = "";
   m_compilerAdditionalOptions = "";
   m_assemblerDefinedSymbols = "";
   m_assemblerIncludePaths = "";
   m_assemblerAdditionalOptions = "";
   m_linkerConfigFile = "";
   m_makefileCustomRulesFile = "";
   m_linkerAdditionalOptions = "";
   m_linkerAdditionalDependencies = "";
   m_sourceSearchPaths.clear();

   m_saveStateDoc.clear();

   m_tileProperties.clear();

   m_isInitialized = false;
   m_isDirty = false;
}

bool CNesicideProject::serialize(QDomDocument& doc, QDomNode& node)
{
   // Create a DOM element to define the node this object represents, and add it to the
   // parent node assigned in from the caller.
   QDomElement projectElement = addElement( doc, node, "nesicideproject" );

   // Set some variables as tags to this node.
   projectElement.setAttribute("version", "0.3");
   projectElement.setAttribute("target", m_projectTarget);
   projectElement.setAttribute("title", m_projectTitle);

   // Create the project configuration node.
   QDomElement propertiesElement = addElement(doc,projectElement,"properties");

   propertiesElement.setAttribute("outputbasepath",m_projectOutputBasePath);
   propertiesElement.setAttribute("linkeroutputbasepath",m_projectLinkerOutputBasePath);
   propertiesElement.setAttribute("linkeroutputname",m_projectLinkerOutputName);
   propertiesElement.setAttribute("debuginfoname",m_projectDebugInfoName);
   propertiesElement.setAttribute("compilerdefinedsymbols",m_compilerDefinedSymbols);
   propertiesElement.setAttribute("compilerincludepaths",m_compilerIncludePaths);
   propertiesElement.setAttribute("compileradditionaloptions",m_compilerAdditionalOptions);
   propertiesElement.setAttribute("assemblerdefinedsymbols",m_assemblerDefinedSymbols);
   propertiesElement.setAttribute("assemblerincludepaths",m_assemblerIncludePaths);
   propertiesElement.setAttribute("assembleradditionaloptions",m_assemblerAdditionalOptions);
   propertiesElement.setAttribute("linkerconfigfile",m_linkerConfigFile);
   propertiesElement.setAttribute("customrulesfile",m_makefileCustomRulesFile);
   propertiesElement.setAttribute("linkeradditionaloptions",m_linkerAdditionalOptions);
   propertiesElement.setAttribute("linkeradditionaldependencies",m_linkerAdditionalDependencies);
   propertiesElement.setAttribute("sourcesearchpaths",m_sourceSearchPaths.join(";"));

   // These are NES-specific properties.
   if ( !m_projectTarget.compare("nes",Qt::CaseInsensitive) )
   {
      propertiesElement.setAttribute("outputname",m_projectOutputName);
      propertiesElement.setAttribute("headerfilename",m_projectHeaderFileName);
      propertiesElement.setAttribute("sourcefilename",m_projectSourceFileName);
      propertiesElement.setAttribute("chrromoutputbasepath",m_projectCHRROMOutputBasePath);
      propertiesElement.setAttribute("chrromoutputname",m_projectCHRROMOutputName);
      propertiesElement.setAttribute("chrrom",m_projectUsesCHRROM);
      propertiesElement.setAttribute("cartridgeoutputname",m_projectCartridgeOutputName);
      propertiesElement.setAttribute("cartridgesavestatename",m_projectCartridgeSaveStateName);
   }

   // These are NES-specific properties.
   if ( !m_projectTarget.compare("nes",Qt::CaseInsensitive) )
   {
      QDomElement tilePropertiesElement = addElement(doc,propertiesElement,"tileproperties");

      foreach ( PropertyItem item, m_tileProperties )
      {
         QDomElement elm = addElement(doc,tilePropertiesElement,"property");
         elm.setAttribute("name",item.name);
         elm.setAttribute("type",item.type);
         elm.setAttribute("value",item.value);
      }
   }

   QDomElement inspectorsElement = addElement(doc,projectElement,"inspectors");

   // These are target-independent inspectors.
   SymbolWatchDockWidget* pSymbolInspector = dynamic_cast<SymbolWatchDockWidget*>(CDockWidgetRegistry::instance()->getWidget("Symbol Inspector"));
   pSymbolInspector->serialize(doc,inspectorsElement);

   BreakpointDockWidget* pBreakpointInspector = dynamic_cast<BreakpointDockWidget*>(CDockWidgetRegistry::instance()->getWidget("Breakpoints"));
   pBreakpointInspector->serialize(doc,inspectorsElement);

   // This is a NES-specific inspector.  So it may not be part of the current UI.
   ExecutionVisualizerDockWidget* pExecutionVisualizer = dynamic_cast<ExecutionVisualizerDockWidget*>(CDockWidgetRegistry::instance()->getWidget("Execution Visualizer"));
   if ( pExecutionVisualizer )
   {
      pExecutionVisualizer->serialize(doc,inspectorsElement);
   }

   // Create the root palette element, and give it a version attribute
   QDomElement rootPaletteElement = addElement( doc, propertiesElement, "palette" );

   // Loop through all palette entries, and for each entry add an <entry /> tag that has the
   // index, as well as the RGB properties of the palette.
   // Palette is target-dependent!
   if ( !m_projectTarget.compare("nes",Qt::CaseInsensitive) )
   {
      for (int indexOfCurrentPaletteEntry=0; indexOfCurrentPaletteEntry < nesGetNumColors(); indexOfCurrentPaletteEntry++)
      {
         QDomElement elm = addElement( doc, rootPaletteElement, "entry");
         elm.setAttribute("index", indexOfCurrentPaletteEntry);
         elm.setAttribute("r", m_projectPaletteEntries.at(indexOfCurrentPaletteEntry).red());
         elm.setAttribute("g", m_projectPaletteEntries.at(indexOfCurrentPaletteEntry).green());
         elm.setAttribute("b", m_projectPaletteEntries.at(indexOfCurrentPaletteEntry).blue());
      }
   }
   else if ( !m_projectTarget.compare("c64",Qt::CaseInsensitive) )
   {
      for (int indexOfCurrentPaletteEntry=0; indexOfCurrentPaletteEntry < c64GetNumColors(); indexOfCurrentPaletteEntry++)
      {
         QDomElement elm = addElement( doc, rootPaletteElement, "entry");
         elm.setAttribute("index", indexOfCurrentPaletteEntry);
         elm.setAttribute("r", m_projectPaletteEntries.at(indexOfCurrentPaletteEntry).red());
         elm.setAttribute("g", m_projectPaletteEntries.at(indexOfCurrentPaletteEntry).green());
         elm.setAttribute("b", m_projectPaletteEntries.at(indexOfCurrentPaletteEntry).blue());
      }
   }

   // Now serialize all child objects.
   // This is a NES-specific project item.
   if ( !m_projectTarget.compare("nes",Qt::CaseInsensitive) )
   {
      if (!m_pCartridge->serialize(doc, projectElement))
      {
         return false;
      }
   }

   if (!m_pProject->serialize(doc, projectElement))
   {
      return false;
   }

   return true;
}

bool CNesicideProject::deserialize(QDomDocument& doc, QDomNode& /*node*/, QString& errors)
{
   // Read in the DOM element
   QDomElement projectElement = doc.documentElement();
   int numColors = 0;

   m_isInitialized = false;

   if (projectElement.isNull())
   {
      return false;
   }

   // For now, error out if the file version is not what we expect it to be. Eventually
   // we need to split up the loader into versions for backwards compatibility.
   if (projectElement.attribute("version", "") != "0.3")
   {
      errors.append("NESICIDE Project files must be version 0.3\n");
      return false;
   }

   // For now, error out if the target is not specified in the XML.
   if ( projectElement.attribute("target").isEmpty() )
   {
      errors.append("Missing required attribute 'target' of element <nesicideproject>\n");
      return false;
   }

   // Load the project target.
   m_projectTarget = projectElement.attribute("target");
   emit createTarget(m_projectTarget);

   // Load our properties. Note that the default value is returned if an attribute is missing.
   // This is the expected behavior.
   m_projectTitle = projectElement.attribute("title","Untitled");

   // Initialize the palette.
   if ( !m_projectTarget.compare("nes",Qt::CaseInsensitive) )
   {
      for (int color = 0; color < nesGetNumColors(); color++)
      {
         m_projectPaletteEntries.append(QColor(nesGetPaletteRedComponent(color),
                                               nesGetPaletteGreenComponent(color),
                                               nesGetPaletteBlueComponent(color)));
      }
   }
   else if ( !m_projectTarget.compare("c64",Qt::CaseInsensitive) )
   {
      for (int color = 0; color < c64GetNumColors(); color++)
      {
         m_projectPaletteEntries.append(QColor(c64GetPaletteRedComponent(color),
                                               c64GetPaletteGreenComponent(color),
                                               c64GetPaletteBlueComponent(color)));
      }
   }

   // Now loop through the child elements and process the ones we find
   QDomNode child = projectElement.firstChild();

   do
   {
      if (child.nodeName() == "inspectors")
      {
         SymbolWatchDockWidget* pSymbolInspector = dynamic_cast<SymbolWatchDockWidget*>(CDockWidgetRegistry::instance()->getWidget("Symbol Inspector"));
         pSymbolInspector->deserialize(doc,child,errors);

         BreakpointDockWidget* pBreakpointInspector = dynamic_cast<BreakpointDockWidget*>(CDockWidgetRegistry::instance()->getWidget("Breakpoints"));
         pBreakpointInspector->deserialize(doc,child,errors);

         // This is a NES-specific inspector.  So it may not be part of the current UI.
         ExecutionVisualizerDockWidget* pExecutionVisualizer = dynamic_cast<ExecutionVisualizerDockWidget*>(CDockWidgetRegistry::instance()->getWidget("Execution Visualizer"));
         if ( pExecutionVisualizer )
         {
            pExecutionVisualizer->deserialize(doc,child,errors);
         }
      }
      else if (child.nodeName() == "properties")
      {
         // Get the properties that are just attributes of the main node.
         QDomElement propertiesElement = child.toElement();

         m_projectOutputBasePath = propertiesElement.attribute("outputbasepath");
         m_projectLinkerOutputBasePath = propertiesElement.attribute("linkeroutputbasepath");
         m_projectLinkerOutputName = propertiesElement.attribute("linkeroutputname");
         m_projectDebugInfoName = propertiesElement.attribute("debuginfoname");
         m_compilerDefinedSymbols = propertiesElement.attribute("compilerdefinedsymbols");
         m_compilerIncludePaths = propertiesElement.attribute("compilerincludepaths");
         m_compilerAdditionalOptions = propertiesElement.attribute("compileradditionaloptions");
         m_assemblerDefinedSymbols = propertiesElement.attribute("assemblerdefinedsymbols");
         m_assemblerIncludePaths = propertiesElement.attribute("assemblerincludepaths");
         m_assemblerAdditionalOptions = propertiesElement.attribute("assembleradditionaloptions");
         m_linkerConfigFile = propertiesElement.attribute("linkerconfigfile");
         m_makefileCustomRulesFile = propertiesElement.attribute("customrulesfile");
         m_linkerAdditionalOptions = propertiesElement.attribute("linkeradditionaloptions");
         m_linkerAdditionalDependencies = propertiesElement.attribute("linkeradditionaldependencies");
         m_sourceSearchPaths.append(propertiesElement.attribute("sourcesearchpaths","").split(";",QString::SkipEmptyParts));
         m_sourceSearchPaths.removeDuplicates();
         m_projectOutputName = propertiesElement.attribute("outputname");

         // These are NES-specific parameters.
         if ( !m_projectTarget.compare("nes",Qt::CaseInsensitive) )
         {
            m_projectHeaderFileName = propertiesElement.attribute("headerfilename",PROJECT_HEADER_FILE);
            m_projectSourceFileName = propertiesElement.attribute("sourcefilename",PROJECT_SOURCE_FILE);
            m_projectCHRROMOutputBasePath = propertiesElement.attribute("chrromoutputbasepath");
            m_projectCHRROMOutputName = propertiesElement.attribute("chrromoutputname");
            m_projectUsesCHRROM = propertiesElement.attribute("chrrom").toInt();
            m_projectCartridgeOutputName = propertiesElement.attribute("cartridgeoutputname");
            m_projectCartridgeSaveStateName = propertiesElement.attribute("cartridgesavestatename");
         }

         // Loop through the properties nodes.
         QDomNode property = child.firstChild();
         do
         {
            if ( !property.isNull() )
            {
               // These are NES-specific project items.
               if ( !m_projectTarget.compare("nes",Qt::CaseInsensitive) )
               {
                  if ( property.nodeName() == "tileproperties" )
                  {
                     // Get the properties that are attributes of the tileproperties node.
                     QDomElement tilePropertiesElement = property.toElement();

                     QDomNode tilePropertyNode = property.firstChild();
                     do
                     {
                        QDomElement tilePropertyItem = tilePropertyNode.toElement();

                        if (!tilePropertyItem.isNull())
                        {

                           if ((!tilePropertyItem.hasAttribute("name"))
                                 || (!tilePropertyItem.hasAttribute("type"))
                                 || (!tilePropertyItem.hasAttribute("value")))
                           {
                              errors.append("Error parsing <tileproperties> element.\n");
                              return false;
                           }

                           PropertyItem item;
                           item.name = tilePropertyItem.attribute("name");
                           item.type = (propertyTypeEnum)tilePropertyItem.attribute("type").toInt();
                           item.value = tilePropertyItem.attribute("value");
                           m_tileProperties.append(item);
                        }
                     }
                     while (!(tilePropertyNode = tilePropertyNode.nextSibling()).isNull());
                  }
               }
               if ( property.nodeName() == "palette" )
               {
                  // Palette is target-dependent!
                  if ( !m_projectTarget.compare("nes",Qt::CaseInsensitive) )
                  {
                     numColors = nesGetNumColors();
                  }
                  else if ( !m_projectTarget.compare("c64",Qt::CaseInsensitive) )
                  {
                     numColors = c64GetNumColors();
                  }

                  QDomNode paletteNode = property.firstChild();
                  do
                  {
                     QDomElement paletteItem = paletteNode.toElement();

                     if (paletteItem.isNull())
                     {
                        return false;
                     }

                     if ((!paletteItem.hasAttribute("index"))
                           || (!paletteItem.hasAttribute("r"))
                           || (!paletteItem.hasAttribute("g"))
                           || (!paletteItem.hasAttribute("b")))
                     {
                        errors.append("Error parsing <nesicidepalette> element.\n");
                        return false;
                     }

                     int nodeIndex = paletteItem.attribute("index").toInt();

                     if ((nodeIndex >= 0) && (nodeIndex < numColors))
                     {
                        m_projectPaletteEntries.replace(nodeIndex,
                                                        QColor(paletteItem.attribute("r").toInt(),
                                                               paletteItem.attribute("g").toInt(),
                                                               paletteItem.attribute("b").toInt()));
                     }
                  }
                  while (!(paletteNode = paletteNode.nextSibling()).isNull());
               }
            }
         } while (!(property = property.nextSibling()).isNull());
      }
      else if (child.nodeName() == "cartridge")
      {
         if ( !m_projectTarget.compare("nes",Qt::CaseInsensitive) )
         {
            if (!m_pCartridge->deserialize(doc,child,errors))
            {
               return false;
            }
         }
      }
      else if (child.nodeName() == "project")
      {
         if (!m_pProject->deserialize(doc,child,errors))
         {
            return false;
         }
      }
   }
   while (!(child = child.nextSibling()).isNull());

   m_isInitialized = true;
   return true;
}

QString CNesicideProject::caption() const
{
   return QString("NESICIDE");
}

void CNesicideProject::addSourceSearchPath(QString value)
{
   m_sourceSearchPaths.append(value);
   m_sourceSearchPaths.removeDuplicates();
}

void CNesicideProject::removeSourceSearchPath(QString value)
{
   m_sourceSearchPaths.removeAll(value);
}

bool CNesicideProject::createProjectFromRom(QString fileName,bool silent)
{
   CCHRROMBanks* chrRomBanks = getCartridge()->getChrRomBanks();
   CPRGROMBanks* prgRomBanks = getCartridge()->getPrgRomBanks();
   int oldBanks;
   int bankIdx;
   QString str;

   QFile fileIn (fileName);

   if (fileIn.exists() && fileIn.open(QIODevice::ReadOnly))
   {
      QDataStream fs(&fileIn);

      // Check the NES header
      char nesHeader[4] = {'N', 'E', 'S', 0x1A};
      char nesTest[4] = {0, 0, 0, 0};
      fs.readRawData(nesTest,4);

      if (memcmp(nesHeader, nesTest,4))
      {
         // Header check failed, quit
         fileIn.close();
         if (!silent)
         {
            QMessageBox::information(0, "Error", "Invalid ROM format.\nCannot create project.");
         }
         return false;
      }

      // Number of 16 KB PRG-ROM banks
      qint8 numPrgRomBanks;
      fs >> numPrgRomBanks;

      // Convert to 8 KB banks
      numPrgRomBanks <<= 1;

      // Get the number of 8 KB CHR-ROM / VROM banks
      qint8 numChrRomBanks;
      fs >> numChrRomBanks;

      // ROM Control Byte 1:
      // - Bit 0 - Indicates the type of mirroring used by the game
      //   where 0 indicates horizontal mirroring, 1 indicates
      //   vertical mirroring.
      //
      // - Bit 1 - Indicates the presence of battery-backed RAM at
      //   memory locations $6000-$7FFF.
      //
      // - Bit 2 - Indicates the presence of a 512-byte trainer at
      //   memory locations $7000-$71FF.
      //
      // - Bit 3 - If this bit is set it overrides bit 0 to indicate fourscreen
      //   mirroring should be used.
      //
      // - Bits 4-7 - Four lower bits of the mapper number.
      qint8 romCB1;
      fs >> romCB1;

      // First extract the mirror mode
      if ((romCB1&FLAG_MIRROR) == FLAG_MIRROR_VERT)
      {
         m_pCartridge->setMirrorMode(VerticalMirroring);
      }
      else
      {
         m_pCartridge->setMirrorMode(HorizontalMirroring);
      }
      if ((romCB1&FLAG_VRAM) == FLAG_FOURSCREEN_VRAM)
      {
         m_pCartridge->setFourScreen(true);
      }

      // Now extract the two flags (battery backed ram and trainer)
      m_pCartridge->setBatteryBackedRam(romCB1 & 0x02);
      bool hasTrainer = (romCB1 & 0x04);

      // ROM Control Byte 2:
      //  Bits 0-3 - Reserved for future usage and should all be 0.
      //  Bits 4-7 - Four upper bits of the mapper number.
      qint8 romCB2;
      fs >> romCB2;

      if ( romCB2&0x0F )
      {
         romCB2 = 0x00;
         if (!silent)
         {
            QMessageBox::information(0, "Warning", "Invalid iNES header format.\nSave the project to fix.");
         }
      }

      // Extract the upper four bits of the mapper number
      m_pCartridge->setMapperNumber(((romCB1>>4)&0x0F)|(romCB2&0xF0));

      // Number of 8 KB RAM banks. For compatibility with previous
      // versions of the iNES format, assume 1 page of RAM when
      // this is 0.
      qint8 numRamBanks;
      fs >> numRamBanks;

      if (numRamBanks == 0)
      {
         numRamBanks = 1;
      }

      // Skip the 7 reserved bytes
      qint8 skip;

      for (int i=0; i<7; i++)
      {
         fs >> skip;
      }

      // Extract the trainer (if it exists)
      if (hasTrainer)
      {
         // TODO: Handle trainer. Skipping for now.
         for (int i=0; i<512; i++)
         {
            fs >> skip;
         }
      }

      // Load the PRG-ROM banks (16KB each)
      oldBanks = prgRomBanks->getPrgRomBanks().count();
      bankIdx = 0;
      for (int bank=0; bank<numPrgRomBanks; bank++)
      {
         // Grab either a previously used bank, or a new one
         CPRGROMBank* curBank;
         bool doAppend = (--oldBanks < 0);

         // Initialize the bank into the project banks
         if (doAppend)
         {
            curBank = new CPRGROMBank(nesicideProject->getCartridge()->getPrgRomBanks());
            // This is a new bank
            curBank->setBankIndex(prgRomBanks->getPrgRomBanks().count());
            prgRomBanks->appendChild(curBank);
            prgRomBanks->getPrgRomBanks().append(curBank);
         }
         else
         {
            curBank = prgRomBanks->getPrgRomBanks().at(bankIdx++);
         }

         fs.readRawData((char*)curBank->getBankData(),MEM_8KB);
      }

      // Load the CHR-ROM banks (8KB each)
      oldBanks = chrRomBanks->getChrRomBanks().count();
      bankIdx = 0;
      for (int bank=0; bank<numChrRomBanks; bank++)
      {
         // Grab either a previously used bank, or a new one
         CCHRROMBank* curBank;
         bool doAppend = (--oldBanks < 0);

         // Initialize the bank into the project banks
         if (doAppend)
         {
            curBank = new CCHRROMBank(nesicideProject->getCartridge()->getChrRomBanks());
            // This is a new bank
            curBank->setBankIndex(chrRomBanks->getChrRomBanks().count());
            chrRomBanks->appendChild(curBank);
            chrRomBanks->getChrRomBanks().append(curBank);
         }
         else
         {
            curBank = chrRomBanks->getChrRomBanks().at(bankIdx++);
         }

         fs.readRawData((char*)curBank->getBankData(),MEM_8KB);
      }

      str = "<b>Searcing internal game database: ";
      str += gameDatabase.getGameDBAuthor();
      str += ", ";
      str += gameDatabase.getGameDBTimestamp();
      str += "...</b>";
      generalTextLogger->write(str);
      str = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
      str += fileName;
      generalTextLogger->write(str);

      bool gameFoundInDB = gameDatabase.find(m_pCartridge);

      if ( gameFoundInDB )
      {
         str = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SHA1: ";
         str += gameDatabase.getSHA1();
         generalTextLogger->write(str);

         str = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Name: ";
         str += gameDatabase.getName();
         generalTextLogger->write(str);

         str = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Publisher (date): ";
         str += gameDatabase.getPublisher();
         str += " (";
         str += gameDatabase.getDate();
         str += ")";
         generalTextLogger->write(str);

         // Set project title...
         if ( !silent )
         {
            m_projectTitle = gameDatabase.getName();
         }

         // Do NTSC/PAL autodetecting

         // Check cartridge validity?
      }
      else
      {
         str = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i><font color=\"red\">Not found.</font></i>";
         generalTextLogger->write(str);
      }

      str = "<b>Game loaded.</b>";
      generalTextLogger->write(str);

      fileIn.close();

      return true;
   }

   return false;
}

bool CNesicideProject::createRomFromProject(QString fileName)
{
    CCHRROMBanks* chrRomBanks = getCartridge()->getChrRomBanks();
    CPRGROMBanks* prgRomBanks = getCartridge()->getPrgRomBanks();

    QFile fileOut (fileName);

    if (fileOut.open(QIODevice::ReadWrite|QIODevice::Truncate))
    {
       QDataStream fs(&fileOut);

       // Check the NES header
       char nesHeader[4] = {'N', 'E', 'S', 0x1A};
       fs.writeRawData(nesHeader,4);

       // Number of 16KB PRG-ROM banks
       qint8 numPrgRomBanks = prgRomBanks->getPrgRomBanks().count();

       // iNES header expects 16KB banks
       qint8 numPrgRomBanksHdr = numPrgRomBanks>>1;

       fs << numPrgRomBanksHdr;

       // Get the number of 8KB CHR-ROM / VROM banks
       qint8 numChrRomBanks = chrRomBanks->getChrRomBanks().count();
       fs << numChrRomBanks;

       // ROM Control Byte 1:
       // - Bit 0 - Indicates the type of mirroring used by the game
       //   where 0 indicates horizontal mirroring, 1 indicates
       //   vertical mirroring.
       //
       // - Bit 1 - Indicates the presence of battery-backed RAM at
       //   memory locations $6000-$7FFF.
       //
       // - Bit 2 - Indicates the presence of a 512-byte trainer at
       //   memory locations $7000-$71FF.
       //
       // - Bit 3 - If this bit is set it overrides bit 0 to indicate fourscreen
       //   mirroring should be used.
       //
       // - Bits 4-7 - Four lower bits of the mapper number.
       qint8 romCB1 = 0x00;

       // First extract the mirror mode
       if (m_pCartridge->getMirrorMode() == VerticalMirroring)
       {
          romCB1 |= FLAG_MIRROR_VERT;
       }
       if (m_pCartridge->isBatteryBackedRam())
       {
          romCB1 |= 0x02;
       }
       romCB1 |= ((m_pCartridge->getMapperNumber()&0xF)<<4);

       fs << romCB1;

       // ROM Control Byte 2:
       //  Bits 0-3 - Reserved for future usage and should all be 0.
       //  Bits 4-7 - Four upper bits of the mapper number.
       qint8 romCB2 = 0x00;

       romCB2 |= (m_pCartridge->getMapperNumber()&0xF0);

       fs << romCB2;

       // Skip the 7 reserved bytes
       qint8 skip = 0;

       for (int i=0; i<8; i++)
       {
          fs << skip;
       }

       // Ignore trainer.

       // Save the PRG-ROM banks (16KB each)
       for (int bank=0; bank<numPrgRomBanks; bank++)
       {
          // Grab either a previously used bank, or a new one
          CPRGROMBank* curBank = prgRomBanks->getPrgRomBanks().at(bank);

          fs.writeRawData((char*)curBank->getBankData(),MEM_8KB);
       }

       // Save the CHR-ROM banks (8KB each)
       for (int bank=0; bank<numChrRomBanks; bank++)
       {
          // Grab either a previously used bank, or a new one
          CCHRROMBank* curBank = chrRomBanks->getChrRomBanks().at(bank);

          fs.writeRawData((char*)curBank->getBankData(),MEM_8KB);
       }

       fileOut.close();

       return true;
    }

    return false;
}

bool CNesicideProject::exportData()
{
   QDir dir(QDir::currentPath());
   QString projHdrFileName = dir.fromNativeSeparators(dir.relativeFilePath(nesicideProject->getProjectHeaderFileName()));
   QFile projHdrFile(projHdrFileName);
   QList<PropertyEnumItem> items;
   bool ok = false;

   // This function exports project-specific data such as property enumerations
   // declared in the Project Properties panel.
   if ( projHdrFile.open(QIODevice::ReadWrite|QIODevice::Text|QIODevice::Truncate) )
   {
      projHdrFile.write(NESICIDE_HEADER);

      foreach ( PropertyItem propertyItem, m_tileProperties )
      {
         if ( propertyItem.type == propertyEnumeration )
         {
            projHdrFile.write(".enum ");
            projHdrFile.write(propertyItem.name.toLatin1());
            projHdrFile.write("\n");

            items = getEnumItems(propertyItem.value);
            foreach ( PropertyEnumItem enumItem, items )
            {
               projHdrFile.write("\t");
               projHdrFile.write(enumItem.symbol.toLatin1());
               projHdrFile.write(" = ");
               projHdrFile.write(enumItem.value.toLatin1());
               projHdrFile.write("\n");
            }

            projHdrFile.write(".endenum\n\n");
         }
      }

      ok = true;

      projHdrFile.close();
   }

   return ok;
}

QString CNesicideProject::getMakefileCustomRules()
{
   QDir dir(QDir::currentPath());
   QString rules;

   if ( !m_makefileCustomRulesFile.isEmpty() )
   {
      QFile fileIn(dir.filePath(m_makefileCustomRulesFile));

      if ( fileIn.exists() )
      {
         fileIn.open(QIODevice::ReadOnly|QIODevice::Text);
         if ( fileIn.isOpen() )
         {
            rules = fileIn.readAll();
            fileIn.close();
         }
         else
         {
            QMessageBox::critical(0,"File I/O Error", "Could not read custom rules file:\n"+m_makefileCustomRulesFile);
         }
      }
   }

   return rules;
}
